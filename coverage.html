
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">sun-stockanalysis-api/cmd/api/main.go (0.0%)</option>
				
				<option value="file1">sun-stockanalysis-api/internal/authctx/context.go (0.0%)</option>
				
				<option value="file2">sun-stockanalysis-api/internal/configurations/configurations.go (0.0%)</option>
				
				<option value="file3">sun-stockanalysis-api/internal/controllers/auth_controller.go (100.0%)</option>
				
				<option value="file4">sun-stockanalysis-api/internal/controllers/company_news_controller.go (0.0%)</option>
				
				<option value="file5">sun-stockanalysis-api/internal/controllers/controllers.go (0.0%)</option>
				
				<option value="file6">sun-stockanalysis-api/internal/controllers/health_controller.go (0.0%)</option>
				
				<option value="file7">sun-stockanalysis-api/internal/controllers/push_subscription_controller.go (0.0%)</option>
				
				<option value="file8">sun-stockanalysis-api/internal/controllers/relation_news_controller.go (0.0%)</option>
				
				<option value="file9">sun-stockanalysis-api/internal/controllers/stock_controller.go (0.0%)</option>
				
				<option value="file10">sun-stockanalysis-api/internal/controllers/stock_daily_controller.go (0.0%)</option>
				
				<option value="file11">sun-stockanalysis-api/internal/controllers/stock_quote_controller.go (0.0%)</option>
				
				<option value="file12">sun-stockanalysis-api/internal/database/health.go (0.0%)</option>
				
				<option value="file13">sun-stockanalysis-api/internal/database/postgresDatabase.go (0.0%)</option>
				
				<option value="file14">sun-stockanalysis-api/internal/domains/alert_events/service.go (0.0%)</option>
				
				<option value="file15">sun-stockanalysis-api/internal/domains/auth/service.go (74.4%)</option>
				
				<option value="file16">sun-stockanalysis-api/internal/domains/cleanup/service.go (0.0%)</option>
				
				<option value="file17">sun-stockanalysis-api/internal/domains/company_news/service.go (0.0%)</option>
				
				<option value="file18">sun-stockanalysis-api/internal/domains/market_open/service.go (0.0%)</option>
				
				<option value="file19">sun-stockanalysis-api/internal/domains/push_subscriptions/service.go (0.0%)</option>
				
				<option value="file20">sun-stockanalysis-api/internal/domains/relation_news/service.go (0.0%)</option>
				
				<option value="file21">sun-stockanalysis-api/internal/domains/stock/service.go (0.0%)</option>
				
				<option value="file22">sun-stockanalysis-api/internal/domains/stock_daily/service.go (0.0%)</option>
				
				<option value="file23">sun-stockanalysis-api/internal/domains/stock_quotes/service.go (0.0%)</option>
				
				<option value="file24">sun-stockanalysis-api/internal/handler/auth_middleware.go (0.0%)</option>
				
				<option value="file25">sun-stockanalysis-api/internal/handler/handler.go (0.0%)</option>
				
				<option value="file26">sun-stockanalysis-api/internal/mocks/domains/auth/authservice_mock.go (0.0%)</option>
				
				<option value="file27">sun-stockanalysis-api/internal/mocks/domains/stock/httpclient_mock.go (0.0%)</option>
				
				<option value="file28">sun-stockanalysis-api/internal/mocks/domains/stock/stockservice_mock.go (0.0%)</option>
				
				<option value="file29">sun-stockanalysis-api/internal/mocks/repository/healthrepository_mock.go (0.0%)</option>
				
				<option value="file30">sun-stockanalysis-api/internal/mocks/repository/refreshtokenrepository_mock.go (0.0%)</option>
				
				<option value="file31">sun-stockanalysis-api/internal/mocks/repository/stockrepository_mock.go (0.0%)</option>
				
				<option value="file32">sun-stockanalysis-api/internal/mocks/repository/userrepository_mock.go (0.0%)</option>
				
				<option value="file33">sun-stockanalysis-api/internal/models/alert_events.go (0.0%)</option>
				
				<option value="file34">sun-stockanalysis-api/internal/models/company_news.go (0.0%)</option>
				
				<option value="file35">sun-stockanalysis-api/internal/models/local_time.go (0.0%)</option>
				
				<option value="file36">sun-stockanalysis-api/internal/models/market_open.go (0.0%)</option>
				
				<option value="file37">sun-stockanalysis-api/internal/models/master.go (0.0%)</option>
				
				<option value="file38">sun-stockanalysis-api/internal/models/push_subscription.go (0.0%)</option>
				
				<option value="file39">sun-stockanalysis-api/internal/models/relation_news.go (0.0%)</option>
				
				<option value="file40">sun-stockanalysis-api/internal/models/stock_daily.go (0.0%)</option>
				
				<option value="file41">sun-stockanalysis-api/internal/models/stock_quote.go (0.0%)</option>
				
				<option value="file42">sun-stockanalysis-api/internal/realtime/alert_hub.go (0.0%)</option>
				
				<option value="file43">sun-stockanalysis-api/internal/realtime/composite_alert_notifier.go (0.0%)</option>
				
				<option value="file44">sun-stockanalysis-api/internal/realtime/stock_quote_hub.go (0.0%)</option>
				
				<option value="file45">sun-stockanalysis-api/internal/repository/alert_events.go (0.0%)</option>
				
				<option value="file46">sun-stockanalysis-api/internal/repository/company_news.go (0.0%)</option>
				
				<option value="file47">sun-stockanalysis-api/internal/repository/health.go (0.0%)</option>
				
				<option value="file48">sun-stockanalysis-api/internal/repository/market_open.go (0.0%)</option>
				
				<option value="file49">sun-stockanalysis-api/internal/repository/push_subscription.go (0.0%)</option>
				
				<option value="file50">sun-stockanalysis-api/internal/repository/refresh_token.go (0.0%)</option>
				
				<option value="file51">sun-stockanalysis-api/internal/repository/relation_news.go (0.0%)</option>
				
				<option value="file52">sun-stockanalysis-api/internal/repository/stock.go (0.0%)</option>
				
				<option value="file53">sun-stockanalysis-api/internal/repository/stock_daily.go (0.0%)</option>
				
				<option value="file54">sun-stockanalysis-api/internal/repository/stock_quotes.go (0.0%)</option>
				
				<option value="file55">sun-stockanalysis-api/internal/repository/user.go (0.0%)</option>
				
				<option value="file56">sun-stockanalysis-api/internal/routes/routes_auth.go (0.0%)</option>
				
				<option value="file57">sun-stockanalysis-api/internal/routes/routes_base.go (0.0%)</option>
				
				<option value="file58">sun-stockanalysis-api/internal/routes/routes_company_news.go (0.0%)</option>
				
				<option value="file59">sun-stockanalysis-api/internal/routes/routes_health.go (0.0%)</option>
				
				<option value="file60">sun-stockanalysis-api/internal/routes/routes_push_subscriptions.go (0.0%)</option>
				
				<option value="file61">sun-stockanalysis-api/internal/routes/routes_relation_news.go (0.0%)</option>
				
				<option value="file62">sun-stockanalysis-api/internal/routes/routes_stock.go (0.0%)</option>
				
				<option value="file63">sun-stockanalysis-api/internal/routes/routes_stock_daily.go (0.0%)</option>
				
				<option value="file64">sun-stockanalysis-api/internal/routes/routes_stock_quotes.go (0.0%)</option>
				
				<option value="file65">sun-stockanalysis-api/internal/server/server.go (0.0%)</option>
				
				<option value="file66">sun-stockanalysis-api/pkg/apierror/api_error.go (0.0%)</option>
				
				<option value="file67">sun-stockanalysis-api/pkg/apierror/http.go (0.0%)</option>
				
				<option value="file68">sun-stockanalysis-api/pkg/apierror/huma.go (0.0%)</option>
				
				<option value="file69">sun-stockanalysis-api/pkg/logger/logger.go (0.0%)</option>
				
				<option value="file70">sun-stockanalysis-api/pkg/response/response.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        "sun-stockanalysis-api/internal/configurations"
        "sun-stockanalysis-api/internal/controllers"
        "sun-stockanalysis-api/internal/database"
        "sun-stockanalysis-api/internal/domains/alert_events"
        "sun-stockanalysis-api/internal/domains/auth"
        "sun-stockanalysis-api/internal/domains/cleanup"
        "sun-stockanalysis-api/internal/domains/company_news"
        "sun-stockanalysis-api/internal/domains/market_open"
        "sun-stockanalysis-api/internal/domains/push_subscriptions"
        "sun-stockanalysis-api/internal/domains/relation_news"
        "sun-stockanalysis-api/internal/domains/stock"
        "sun-stockanalysis-api/internal/domains/stock_daily"
        "sun-stockanalysis-api/internal/domains/stock_quotes"
        "sun-stockanalysis-api/internal/models"
        "sun-stockanalysis-api/internal/realtime"
        "sun-stockanalysis-api/internal/repository"
        "sun-stockanalysis-api/internal/server"
        "sun-stockanalysis-api/pkg/logger"
)

func main() <span class="cov0" title="0">{
        if loc, err := time.LoadLocation("Asia/Bangkok"); err == nil </span><span class="cov0" title="0">{
                time.Local = loc
        }</span>
        <span class="cov0" title="0">cfg := configurations.ConfigGetting()
        logg := logger.NewLogger(getEnvString("LOG_LEVEL", "info"))
        defer logg.Sync()
        // DB
        db := database.NewPostgresDatabase(cfg.Database).ConnectionGetting()

        // (optional) migrate
        if err := db.AutoMigrate(
                &amp;models.Stock{},
                &amp;models.StockQuote{},
                &amp;models.User{},
                &amp;models.RefreshTokens{},
                &amp;models.MasterAssetType{},
                &amp;models.MasterExchange{},
                &amp;models.MasterSector{},
                &amp;models.MarketOpen{},
                &amp;models.StockDaily{},
                &amp;models.RelationNews{},
                &amp;models.CompanyNews{},
                &amp;models.AlertEvent{},
                &amp;models.PushSubscription{},
        ); err != nil </span><span class="cov0" title="0">{
                logg.Fatalf("migrate error: %v", err)
        }</span>

        // DI wiring
        <span class="cov0" title="0">stockRepo := repository.NewStockRepository(db)
        stockService := stock.NewStockService(stockRepo, nil, cfg.Finnhub.Token)
        stockController := controllers.NewStockController(stockService)
        stockQuoteRepo := repository.NewStockQuoteRepository(db)
        alertEventRepo := repository.NewAlertEventRepository(db)
        pushSubscriptionRepo := repository.NewPushSubscriptionRepository(db)
        alertHub := realtime.NewAlertHub()
        stockQuoteHub := realtime.NewStockQuoteHub()
        pushSubscriptionService, err := push_subscriptions.NewPushSubscriptionService(pushSubscriptionRepo, cfg.Push)
        if err != nil </span><span class="cov0" title="0">{
                logg.Fatalf("push subscription init error: %v", err)
        }</span>
        <span class="cov0" title="0">alertNotifier := realtime.NewCompositeAlertNotifier(alertHub, pushSubscriptionService)
        alertEventService := alert_events.NewAlertEventService(stockQuoteRepo, alertEventRepo, alertNotifier)
        stockQuoteService := stock_quotes.NewStockQuoteService(stockRepo, stockQuoteRepo, alertEventService, stockQuoteHub, nil, cfg.Finnhub.Token)
        stockQuoteController := controllers.NewStockQuoteController(stockQuoteService)
        stockDailyRepo := repository.NewStockDailyRepository(db)
        stockDailyService := stock_daily.NewStockDailyService(stockRepo, stockQuoteRepo, stockDailyRepo)
        stockDailyController := controllers.NewStockDailyController(stockDailyService)
        relationNewsRepo := repository.NewRelationNewsRepository(db)
        relationNewsService := relation_news.NewRelationNewsService(relationNewsRepo)
        companyNewsRepo := repository.NewCompanyNewsRepository(db)
        companyNewsService := company_news.NewCompanyNewsService(relationNewsRepo, companyNewsRepo, pushSubscriptionService, nil, cfg.Finnhub.Token, logg)
        companyNewsController := controllers.NewCompanyNewsController(companyNewsService)
        healthRepo := repository.NewHealthRepository(db)
        userRepo := repository.NewUserRepository(db)
        refreshTokenRepo := repository.NewRefreshTokenRepository(db)
        authService := auth.NewAuthService(userRepo, refreshTokenRepo, cfg.State)
        authController := controllers.NewAuthController(authService)
        relationNewsController := controllers.NewRelationNewsController(relationNewsService)
        pushSubscriptionController := controllers.NewPushSubscriptionController(pushSubscriptionService)
        marketOpenRepo := repository.NewMarketOpenRepository(db)
        marketOpenService := market_open.NewMarketOpenService(marketOpenRepo, nil, cfg.Finnhub.Token, stockQuoteService, stockDailyService, pushSubscriptionService, logg)
        cleanupService := cleanup.NewCleanupService(
                stockQuoteRepo,
                companyNewsRepo,
                alertEventRepo,
                marketOpenRepo,
                refreshTokenRepo,
                pushSubscriptionRepo,
                15,
                7,
                7,
                30,
                30,
        )
        marketOpenService.Start(context.Background())
        companyNewsService.Start(context.Background())
        cleanupService.Start(context.Background())

        healthController := controllers.NewHealthController(healthRepo, "1.0.0")
        appControllers := controllers.NewControllers(
                healthController,
                stockController,
                stockQuoteController,
                stockDailyController,
                companyNewsController,
                authController,
                relationNewsController,
                pushSubscriptionController,
        )

        // Fiber server
        srv := server.NewServer(cfg, appControllers, alertHub, stockQuoteHub, logg)

        go func() </span><span class="cov0" title="0">{
                logg.Infof("server starting on :%d", cfg.Server.Port)
                if err := srv.Start(); err != nil </span><span class="cov0" title="0">{
                        logg.Fatalf("server error: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
        sig := &lt;-sigChan
        logg.Infof("shutdown signal received: %v", sig)
        if err := srv.Stop(); err != nil </span><span class="cov0" title="0">{
                logg.Errorf("server shutdown error: %v", err)
        }</span>
        <span class="cov0" title="0">logg.Info("server stopped gracefully")</span>
}

func getEnvString(key, fallback string) string <span class="cov0" title="0">{
        if v := strings.TrimSpace(os.Getenv(key)); v != "" </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov0" title="0">return fallback</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package authctx

import "context"

type contextKey struct{}

var userIDContextKey contextKey

func UserIDContextKey() any <span class="cov0" title="0">{
        return userIDContextKey
}</span>

func UserIDFromContext(ctx context.Context) (string, bool) <span class="cov0" title="0">{
        if ctx == nil </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov0" title="0">userID, ok := ctx.Value(userIDContextKey).(string)
        if !ok || userID == "" </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov0" title="0">return userID, true</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package configurations

import (
        "bytes"
        "os"
        "strings"
        "sync"
        "time"

        "github.com/go-playground/validator/v10"
        "github.com/joho/godotenv"
        "github.com/spf13/viper"
)

type (
        Config struct {
                Server *Server `mapstructure:"server" validate:"required"`
                // OAuth2           *OAuth2           `mapstructure:"oauth2" validate:"required"`
                State    *State    `mapstructure:"state" validate:"required"`
                Database *Database `mapstructure:"database" validate:"required"`
                Finnhub  *Finnhub  `mapstructure:"finnhub" validate:"required"`
                Push     *Push     `mapstructure:"push"`
        }

        Server struct {
                Host           string        `mapstructure:"host" validate:"required"`
                Port           int           `mapstructure:"port" validate:"required"`
                ContextPath    string        `mapstructure:"contextPath" validate:"required"`
                AllowedOrigins []string      `mapstructure:"allowOrigins" validate:"required"`
                BodyLimit      string        `mapstructure:"bodyLimit" validate:"required"`
                TimeOut        time.Duration `mapstructure:"timeout" validate:"required"`
        }

        // OAuth2 struct {
        //         ClientID             string                 `mapstructure:"clientId" validate:"required"`
        //         ClientSecret         string                 `mapstructure:"clientSecret" validate:"required"`
        //         RedirectURL          string                 `mapstructure:"redirectUrl" validate:"required"`
        //         EndPoints                endpoint         `mapstructure:"endpoints" validate:"required"`
        //         Scopes                        []string        `mapstructure:"scopes" validate:"required"`
        //         UserInfoUrl                string                 `mapstructure:"userInfoUrl" validate:"required"`
        //         revokeUrl                string                 `mapstructure:"revokeUrl" validate:"required"`
        // }

        // endpoint struct {
        //         AuthUrl             string                 `mapstructure:"authUrl" validate:"required"`
        //         TokenUrl                 string                 `mapstructure:"tokenUrl" validate:"required"`
        //         DeviceAuthUrl          string                 `mapstructure:"deviceAuthUrl" validate:"required"`
        // }

        State struct {
                Secret     string        `mapstructure:"secret" validate:"required"`
                ExpiredsAt time.Duration `mapstructure:"expiredsAt" validate:"required"`
                Issuer     string        `mapstructure:"issuer" validate:"required"`
        }

        Database struct {
                Host     string `mapstructure:"host" validate:"required"`
                Port     int    `mapstructure:"port" validate:"required"`
                User     string `mapstructure:"user" validate:"required"`
                Password string `mapstructure:"password" validate:"required"`
                DBname   string `mapstructure:"dbname" validate:"required"`
                SSLmode  string `mapstructure:"sslmode" validate:"required"`
                Schema   string `mapstructure:"schema" validate:"required"`
        }

        Finnhub struct {
                Token string `mapstructure:"token" validate:"required"`
        }

        Push struct {
                Subject         string `mapstructure:"subject"`
                TriggerScore    int    `mapstructure:"triggerScore"`
                VAPIDPublicKey  string `mapstructure:"vapidPublicKey"`
                VAPIDPrivateKey string `mapstructure:"vapidPrivateKey"`
        }
)

var (
        once           sync.Once //Singleton
        configInstance *Config
)

func ConfigGetting() *Config <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                loadDotEnv()

                viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
                viper.AutomaticEnv()
                bindEnvKeys()

                if viper.IsSet("server.allowOrigins") </span><span class="cov0" title="0">{
                        raw := strings.TrimSpace(viper.GetString("server.allowOrigins"))
                        if raw != "" </span><span class="cov0" title="0">{
                                parts := strings.Split(raw, ",")
                                cleaned := make([]string, 0, len(parts))
                                for i := range parts </span><span class="cov0" title="0">{
                                        parts[i] = strings.TrimSpace(parts[i])
                                        if parts[i] != "" </span><span class="cov0" title="0">{
                                                cleaned = append(cleaned, parts[i])
                                        }</span>
                                }
                                <span class="cov0" title="0">if len(cleaned) &gt; 0 </span><span class="cov0" title="0">{
                                        viper.Set("server.allowOrigins", cleaned)
                                }</span>
                        }
                }

                <span class="cov0" title="0">cfg := Config{
                        Server: &amp;Server{
                                Host:           viper.GetString("server.host"),
                                Port:           viper.GetInt("server.port"),
                                ContextPath:    viper.GetString("server.contextPath"),
                                AllowedOrigins: viper.GetStringSlice("server.allowOrigins"),
                                BodyLimit:      viper.GetString("server.bodyLimit"),
                                TimeOut:        viper.GetDuration("server.timeout"),
                        },
                        State: &amp;State{
                                Secret:     viper.GetString("state.secret"),
                                ExpiredsAt: viper.GetDuration("state.expiredsAt"),
                                Issuer:     viper.GetString("state.issuer"),
                        },
                        Database: &amp;Database{
                                Host:     viper.GetString("database.host"),
                                Port:     viper.GetInt("database.port"),
                                User:     viper.GetString("database.user"),
                                Password: viper.GetString("database.password"),
                                DBname:   viper.GetString("database.dbname"),
                                SSLmode:  viper.GetString("database.sslmode"),
                                Schema:   viper.GetString("database.schema"),
                        },
                        Finnhub: &amp;Finnhub{
                                Token: viper.GetString("finnhub.token"),
                        },
                        Push: &amp;Push{
                                Subject:         viper.GetString("push.subject"),
                                TriggerScore:    viper.GetInt("push.triggerScore"),
                                VAPIDPublicKey:  viper.GetString("push.vapidPublicKey"),
                                VAPIDPrivateKey: viper.GetString("push.vapidPrivateKey"),
                        },
                }

                if err := validator.New().Struct(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }

                <span class="cov0" title="0">configInstance = &amp;cfg</span>
        })

        <span class="cov0" title="0">return configInstance</span>
}

func loadDotEnv() <span class="cov0" title="0">{
        paths := []string{
                ".env",
                "../.env",
                "../../.env",
                ".env.prod",
                "../.env.prod",
                "../../.env.prod",
        }

        for _, path := range paths </span><span class="cov0" title="0">{
                data, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Some Windows editors save UTF-8 files with BOM; trim it for dotenv parsing.
                <span class="cov0" title="0">data = bytes.TrimPrefix(data, []byte{0xEF, 0xBB, 0xBF})

                envMap, err := godotenv.Unmarshal(string(data))
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for key, value := range envMap </span><span class="cov0" title="0">{
                        if _, exists := os.LookupEnv(key); !exists </span><span class="cov0" title="0">{
                                _ = os.Setenv(key, value)
                        }</span>
                }
                <span class="cov0" title="0">return</span>
        }
}

func bindEnvKeys() <span class="cov0" title="0">{
        keys := []string{
                "server.host",
                "server.port",
                "server.contextPath",
                "server.allowOrigins",
                "server.bodyLimit",
                "server.timeout",
                "state.secret",
                "state.expiredsAt",
                "state.issuer",
                "database.host",
                "database.port",
                "database.user",
                "database.password",
                "database.dbname",
                "database.sslmode",
                "database.schema",
                "finnhub.token",
                "push.subject",
                "push.triggerScore",
                "push.vapidPublicKey",
                "push.vapidPrivateKey",
        }

        for _, key := range keys </span><span class="cov0" title="0">{
                _ = viper.BindEnv(key)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package controllers

import (
        "context"
        "net/http"

        "sun-stockanalysis-api/internal/domains/auth"
        "sun-stockanalysis-api/pkg/apierror"
        "sun-stockanalysis-api/pkg/response"
)

type AuthController struct {
        authService auth.AuthService
}

func NewAuthController(authService auth.AuthService) *AuthController <span class="cov8" title="1">{
        return &amp;AuthController{authService: authService}
}</span>

type LoginResponseBody struct {
        AccessToken  string `json:"access_token"`
        RefreshToken string `json:"refresh_token"`
        TokenType    string `json:"token_type"`
        ExpiresIn    int64  `json:"expires_in"`
}

type LoginResponse struct {
        Status int `status:"default"`
        Body   response.ApiResponse[LoginResponseBody]
}

type RegisterResponseBody struct {
        UserID string `json:"user_id"`
}

type RegisterResponse struct {
        Status int `status:"default"`
        Body   response.ApiResponse[RegisterResponseBody]
}

type RefreshResponse struct {
        Status int `status:"default"`
        Body   response.ApiResponse[LoginResponseBody]
}

func (c *AuthController) Login(ctx context.Context, input *auth.LoginInput) (*LoginResponse, error) <span class="cov8" title="1">{
        _ = ctx

        if input.Body.Email == "" || input.Body.Password == "" </span><span class="cov8" title="1">{
                return nil, apierror.NewBadRequest("email and password required")
        }</span>

        <span class="cov8" title="1">result, err := c.authService.Login(*input)
        if err != nil </span><span class="cov8" title="1">{
                if err == auth.ErrInvalidCredentials </span><span class="cov8" title="1">{
                        return nil, apierror.NewUnauthorized("invalid email or password")
                }</span>
                <span class="cov8" title="1">return nil, apierror.NewInternalError(err.Error())</span>
        }

        <span class="cov8" title="1">return &amp;LoginResponse{
                Status: http.StatusOK,
                Body: response.Success(LoginResponseBody{
                        AccessToken:  result.AccessToken,
                        RefreshToken: result.RefreshToken,
                        TokenType:    "Bearer",
                        ExpiresIn:    result.ExpiresIn,
                }),
        }, nil</span>
}

func (c *AuthController) Register(ctx context.Context, input *auth.RegisterInput) (*RegisterResponse, error) <span class="cov8" title="1">{
        _ = ctx

        if input.Body.Email == "" || input.Body.Password == "" </span><span class="cov8" title="1">{
                return nil, apierror.NewBadRequest("email and password required")
        }</span>

        <span class="cov8" title="1">result, err := c.authService.Register(*input)
        if err != nil </span><span class="cov8" title="1">{
                if err == auth.ErrEmailAlreadyExists </span><span class="cov8" title="1">{
                        return nil, apierror.NewBadRequest("email already exists")
                }</span>
                <span class="cov8" title="1">return nil, apierror.NewInternalError(err.Error())</span>
        }

        <span class="cov8" title="1">return &amp;RegisterResponse{
                Status: http.StatusCreated,
                Body: response.Success(RegisterResponseBody{
                        UserID: result.UserID,
                }),
        }, nil</span>
}

func (c *AuthController) Refresh(ctx context.Context, input *auth.RefreshInput) (*RefreshResponse, error) <span class="cov8" title="1">{
        _ = ctx

        if input.Body.RefreshToken == "" </span><span class="cov8" title="1">{
                return nil, apierror.NewBadRequest("refresh_token required")
        }</span>

        <span class="cov8" title="1">result, err := c.authService.Refresh(*input)
        if err != nil </span><span class="cov8" title="1">{
                if err == auth.ErrInvalidRefreshToken </span><span class="cov8" title="1">{
                        return nil, apierror.NewUnauthorized("invalid refresh token")
                }</span>
                <span class="cov8" title="1">return nil, apierror.NewInternalError(err.Error())</span>
        }

        <span class="cov8" title="1">return &amp;RefreshResponse{
                Status: http.StatusOK,
                Body: response.Success(LoginResponseBody{
                        AccessToken:  result.AccessToken,
                        RefreshToken: result.RefreshToken,
                        TokenType:    "Bearer",
                        ExpiresIn:    result.ExpiresIn,
                }),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package controllers

import (
        "context"
        "net/http"
        "time"

        "sun-stockanalysis-api/internal/domains/company_news"
        "sun-stockanalysis-api/internal/models"
        "sun-stockanalysis-api/pkg/apierror"
        "sun-stockanalysis-api/pkg/response"
)

type CompanyNewsController struct {
        service company_news.CompanyNewsService
}

func NewCompanyNewsController(service company_news.CompanyNewsService) *CompanyNewsController <span class="cov0" title="0">{
        return &amp;CompanyNewsController{service: service}
}</span>

type CompanyNewsListInput struct {
        Symbol string `query:"symbol" doc:"Base symbol" required:"true"`
        Start  string `query:"start" doc:"Start date (YYYY-MM-DD)" required:"true"`
        End    string `query:"end" doc:"End date (YYYY-MM-DD)" required:"true"`
}

type CompanyNewsListResponse struct {
        Status int `status:"default"`
        Body   response.ApiResponse[[]models.CompanyNews]
}

func (c *CompanyNewsController) ListBySymbolAndDate(ctx context.Context, input *CompanyNewsListInput) (*CompanyNewsListResponse, error) <span class="cov0" title="0">{
        if input == nil || input.Symbol == "" || input.Start == "" || input.End == "" </span><span class="cov0" title="0">{
                return nil, apierror.NewBadRequest("symbol, start, end are required")
        }</span>
        <span class="cov0" title="0">loc := time.FixedZone("Asia/Bangkok", 7*60*60)
        startDate, err := time.ParseInLocation("2006-01-02", input.Start, loc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apierror.NewBadRequest("invalid start date format (YYYY-MM-DD)")
        }</span>
        <span class="cov0" title="0">endDate, err := time.ParseInLocation("2006-01-02", input.End, loc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apierror.NewBadRequest("invalid end date format (YYYY-MM-DD)")
        }</span>
        <span class="cov0" title="0">start := time.Date(startDate.Year(), startDate.Month(), startDate.Day(), 0, 0, 0, 0, loc)
        end := time.Date(endDate.Year(), endDate.Month(), endDate.Day(), 23, 59, 59, 0, loc)

        items, err := c.service.ListBySymbolAndDate(ctx, input.Symbol, start, end)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apierror.NewInternalError(err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;CompanyNewsListResponse{
                Status: http.StatusOK,
                Body:   response.Success(items),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package controllers

type EmptyRequest struct{}

type EmptyResponse struct {
        Status int `status:"default"`
}

type Response[T any] struct {
        Body T
}

type Controllers struct {
        HealthController           *HealthController
        StockController            *StockController
        StockQuoteController       *StockQuoteController
        StockDailyController       *StockDailyController
        CompanyNewsController      *CompanyNewsController
        AuthController             *AuthController
        RelationNewsController     *RelationNewsController
        PushSubscriptionController *PushSubscriptionController
}

func NewControllers(
        healthController *HealthController,
        stockController *StockController,
        stockQuoteController *StockQuoteController,
        stockDailyController *StockDailyController,
        companyNewsController *CompanyNewsController,
        authController *AuthController,
        relationNewsController *RelationNewsController,
        pushSubscriptionController *PushSubscriptionController,
) *Controllers <span class="cov0" title="0">{
        return &amp;Controllers{
                HealthController:           healthController,
                StockController:            stockController,
                StockQuoteController:       stockQuoteController,
                StockDailyController:       stockDailyController,
                CompanyNewsController:      companyNewsController,
                AuthController:             authController,
                RelationNewsController:     relationNewsController,
                PushSubscriptionController: pushSubscriptionController,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package controllers

import (
        "context"

        "sun-stockanalysis-api/internal/repository"
)

type HealthController struct {
        healthRepository repository.HealthRepository
        serverVersion    string
}

func NewHealthController(healthRepository repository.HealthRepository, serverVersion string) *HealthController <span class="cov0" title="0">{
        return &amp;HealthController{
                healthRepository: healthRepository,
                serverVersion:    serverVersion,
        }
}</span>

type HealthRequest struct {
}

type HealthResponseBody struct {
        Version string `json:"version"`
}

func (hc *HealthController) Healthz(ctx context.Context, req *EmptyRequest) (*Response[HealthResponseBody], error) <span class="cov0" title="0">{
        return &amp;Response[HealthResponseBody]{
                Body: HealthResponseBody{
                        Version: hc.serverVersion,
                },
        }, nil
}</span>

func (hc *HealthController) Readyz(ctx context.Context, req *EmptyRequest) (*EmptyResponse, error) <span class="cov0" title="0">{
        err := hc.healthRepository.CheckDBStatus(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;EmptyResponse{
                Status: 200,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package controllers

import (
        "context"
        "net/http"

        "sun-stockanalysis-api/internal/authctx"
        "sun-stockanalysis-api/internal/domains/push_subscriptions"
        "sun-stockanalysis-api/pkg/apierror"
        "sun-stockanalysis-api/pkg/response"
)

type PushSubscriptionController struct {
        service push_subscriptions.PushSubscriptionService
}

func NewPushSubscriptionController(service push_subscriptions.PushSubscriptionService) *PushSubscriptionController <span class="cov0" title="0">{
        return &amp;PushSubscriptionController{service: service}
}</span>

type PushSubscriptionUpsertInput struct {
        Body struct {
                DeviceID     string `json:"device_id"`
                UserAgent    string `json:"user_agent"`
                Subscription struct {
                        Endpoint string `json:"endpoint"`
                        Keys     struct {
                                P256DH string `json:"p256dh"`
                                Auth   string `json:"auth"`
                        } `json:"keys"`
                } `json:"subscription"`
        }
}

type PushSubscriptionUpsertResponseBody struct {
        Saved bool `json:"saved"`
}

type PushSubscriptionUpsertResponse struct {
        Status int `status:"default"`
        Body   response.ApiResponse[PushSubscriptionUpsertResponseBody]
}

type PushSubscriptionDeleteInput struct {
        DeviceID string `query:"device_id" doc:"Device identifier to unsubscribe"`
}

type PushSubscriptionDeleteResponseBody struct {
        Deleted bool `json:"deleted"`
}

type PushSubscriptionDeleteResponse struct {
        Status int `status:"default"`
        Body   response.ApiResponse[PushSubscriptionDeleteResponseBody]
}

type VAPIDPublicKeyResponseBody struct {
        PublicKey string `json:"public_key"`
}

type VAPIDPublicKeyResponse struct {
        Status int `status:"default"`
        Body   response.ApiResponse[VAPIDPublicKeyResponseBody]
}

func (c *PushSubscriptionController) Upsert(ctx context.Context, input *PushSubscriptionUpsertInput) (*PushSubscriptionUpsertResponse, error) <span class="cov0" title="0">{
        userID, ok := authctx.UserIDFromContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, apierror.NewUnauthorized("invalid token context")
        }</span>
        <span class="cov0" title="0">if input == nil </span><span class="cov0" title="0">{
                return nil, apierror.NewBadRequest("request body required")
        }</span>

        <span class="cov0" title="0">err := c.service.Save(ctx, userID, push_subscriptions.SaveSubscriptionInput{
                DeviceID:  input.Body.DeviceID,
                Endpoint:  input.Body.Subscription.Endpoint,
                P256DHKey: input.Body.Subscription.Keys.P256DH,
                AuthKey:   input.Body.Subscription.Keys.Auth,
                UserAgent: input.Body.UserAgent,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, apierror.NewBadRequest(err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;PushSubscriptionUpsertResponse{
                Status: http.StatusOK,
                Body: response.Success(PushSubscriptionUpsertResponseBody{
                        Saved: true,
                }),
        }, nil</span>
}

func (c *PushSubscriptionController) GetVAPIDPublicKey(ctx context.Context, _ *EmptyRequest) (*VAPIDPublicKeyResponse, error) <span class="cov0" title="0">{
        userID, ok := authctx.UserIDFromContext(ctx)
        if !ok || userID == "" </span><span class="cov0" title="0">{
                return nil, apierror.NewUnauthorized("invalid token context")
        }</span>
        <span class="cov0" title="0">publicKey, err := c.service.GetPublicKey(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apierror.NewInternalError(err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;VAPIDPublicKeyResponse{
                Status: http.StatusOK,
                Body: response.Success(VAPIDPublicKeyResponseBody{
                        PublicKey: publicKey,
                }),
        }, nil</span>
}

func (c *PushSubscriptionController) Delete(ctx context.Context, input *PushSubscriptionDeleteInput) (*PushSubscriptionDeleteResponse, error) <span class="cov0" title="0">{
        userID, ok := authctx.UserIDFromContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return nil, apierror.NewUnauthorized("invalid token context")
        }</span>
        <span class="cov0" title="0">if input == nil || input.DeviceID == "" </span><span class="cov0" title="0">{
                return nil, apierror.NewBadRequest("device_id required")
        }</span>

        <span class="cov0" title="0">if err := c.service.Delete(ctx, userID, input.DeviceID); err != nil </span><span class="cov0" title="0">{
                return nil, apierror.NewBadRequest(err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;PushSubscriptionDeleteResponse{
                Status: http.StatusOK,
                Body: response.Success(PushSubscriptionDeleteResponseBody{
                        Deleted: true,
                }),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package controllers

import (
        "context"
        "net/http"

        "sun-stockanalysis-api/internal/domains/relation_news"
        "sun-stockanalysis-api/pkg/apierror"
        "sun-stockanalysis-api/pkg/response"
)

type RelationNewsController struct {
        service relation_news.RelationNewsService
}

func NewRelationNewsController(service relation_news.RelationNewsService) *RelationNewsController <span class="cov0" title="0">{
        return &amp;RelationNewsController{service: service}
}</span>

type CreateRelationNewsResponse struct {
        Status int `status:"default"`
        Body   response.ApiResponse[any]
}

func (c *RelationNewsController) Create(ctx context.Context, input *relation_news.CreateRelationNewsInput) (*CreateRelationNewsResponse, error) <span class="cov0" title="0">{
        _ = ctx

        if input == nil </span><span class="cov0" title="0">{
                return nil, apierror.NewBadRequest("request body required")
        }</span>
        <span class="cov0" title="0">if input.Body.Symbol == "" </span><span class="cov0" title="0">{
                return nil, apierror.NewBadRequest("symbol required")
        }</span>

        <span class="cov0" title="0">if err := c.service.CreateRelations(input.Body.Symbol, input.Body.RelationSymbols); err != nil </span><span class="cov0" title="0">{
                return nil, apierror.NewInternalError(err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;CreateRelationNewsResponse{
                Status: http.StatusCreated,
                Body:   response.Success[any]("relation news created successfully"),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package controllers

import (
        "context"
        "net/http"

        "github.com/google/uuid"

        "sun-stockanalysis-api/internal/domains/stock"
        "sun-stockanalysis-api/internal/models"
        "sun-stockanalysis-api/pkg/apierror"
        "sun-stockanalysis-api/pkg/response"
)

type StockController struct {
        stockService stock.StockService
}

func NewStockController(stockService stock.StockService) *StockController <span class="cov0" title="0">{
        return &amp;StockController{stockService: stockService}
}</span>

type GetStockInput struct {
        ID string `path:"id" doc:"Stock ID (UUID)"`
}

type StockResponse struct {
        Status int `status:"default"`
        Body   response.ApiResponse[*models.Stock]
}

func (c *StockController) GetStock(ctx context.Context, input *GetStockInput) (*StockResponse, error) <span class="cov0" title="0">{
        _ = ctx

        id, err := uuid.Parse(input.ID)

        if err != nil </span><span class="cov0" title="0">{
                return nil, apierror.NewBadRequest("invalid stock id")
        }</span>

        <span class="cov0" title="0">s, err := c.stockService.GetStock(id)

        if err != nil </span><span class="cov0" title="0">{
                return nil, apierror.NewNotFound("stock not found")
        }</span>

        <span class="cov0" title="0">return &amp;StockResponse{
                Status: http.StatusOK,
                Body:   response.Success(s),
        }, nil</span>
}

type StockListResponse struct {
        Status int `status:"default"`
        Body   response.ApiResponse[[]models.Stock]
}

func (c *StockController) ListStocks(ctx context.Context, input *EmptyRequest) (*StockListResponse, error) <span class="cov0" title="0">{
        _ = ctx
        _ = input

        stocks, err := c.stockService.ListAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, apierror.NewInternalError(err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;StockListResponse{
                Status: http.StatusOK,
                Body:   response.Success(stocks),
        }, nil</span>
}

type StockCreateResponse struct {
        Status int `status:"default"`
        Body   response.ApiResponse[any]
}

func (c *StockController) CreateStock(ctx context.Context, input *stock.CreateStockInput) (*StockCreateResponse, error) <span class="cov0" title="0">{
        _ = ctx

        if err := validateCreateStockInput(input); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := c.stockService.CreateStock(*input); err != nil </span><span class="cov0" title="0">{
                return nil, apierror.NewInternalError(err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;StockCreateResponse{
                Status: http.StatusCreated,
                Body:   response.Success[any]("stock created successfully"),
        }, nil</span>
}

func validateCreateStockInput(input *stock.CreateStockInput) error <span class="cov0" title="0">{
        if input.Body.Symbol == "" </span><span class="cov0" title="0">{
                return apierror.NewBadRequest("symbol required")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package controllers

import (
        "context"
        "net/http"

        "sun-stockanalysis-api/internal/domains/stock_daily"
        "sun-stockanalysis-api/internal/models"
        "sun-stockanalysis-api/pkg/apierror"
        "sun-stockanalysis-api/pkg/response"
)

type StockDailyController struct {
        service stock_daily.StockDailyService
}

func NewStockDailyController(service stock_daily.StockDailyService) *StockDailyController <span class="cov0" title="0">{
        return &amp;StockDailyController{service: service}
}</span>

type StockDailyListInput struct {
        Symbol string `query:"symbol" doc:"Filter by symbol" required:"true"`
}

type StockDailyListResponse struct {
        Status int `status:"default"`
        Body   response.ApiResponse[[]models.StockDaily]
}

func (c *StockDailyController) ListBySymbol(ctx context.Context, input *StockDailyListInput) (*StockDailyListResponse, error) <span class="cov0" title="0">{
        if input == nil || input.Symbol == "" </span><span class="cov0" title="0">{
                return nil, apierror.NewBadRequest("symbol required")
        }</span>

        <span class="cov0" title="0">metrics, err := c.service.ListBySymbol(ctx, input.Symbol)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apierror.NewInternalError(err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;StockDailyListResponse{
                Status: http.StatusOK,
                Body:   response.Success(metrics),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package controllers

import (
        "context"
        "net/http"

        "sun-stockanalysis-api/internal/domains/stock_quotes"
        "sun-stockanalysis-api/internal/models"
        "sun-stockanalysis-api/pkg/apierror"
        "sun-stockanalysis-api/pkg/response"
)

type StockQuoteController struct {
        service stock_quotes.StockQuoteService
}

func NewStockQuoteController(service stock_quotes.StockQuoteService) *StockQuoteController <span class="cov0" title="0">{
        return &amp;StockQuoteController{service: service}
}</span>

type StockQuoteListResponse struct {
        Status int `status:"default"`
        Body   response.ApiResponse[[]models.StockQuote]
}

type StockQuoteListInput struct {
        Symbol string `query:"symbol" doc:"Filter by symbol"`
}

func (c *StockQuoteController) ListAll(ctx context.Context, input *StockQuoteListInput) (*StockQuoteListResponse, error) <span class="cov0" title="0">{
        symbol := ""
        if input != nil </span><span class="cov0" title="0">{
                symbol = input.Symbol
        }</span>
        <span class="cov0" title="0">quotes, err := c.service.List(ctx, symbol)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apierror.NewInternalError(err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;StockQuoteListResponse{
                Status: http.StatusOK,
                Body:   response.Success(quotes),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package database

import (
        "context"

        "gorm.io/gorm"
)

func CheckPostgresHealth(db *gorm.DB, ctx context.Context) error <span class="cov0" title="0">{
        return db.WithContext(ctx).Exec("SELECT 1").Error
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package database

import (
        "fmt"
        "log"
        "sun-stockanalysis-api/internal/configurations"
        "sync"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

type postgresDatabase struct {
        *gorm.DB
}

var (
        postgreDatebaseInstance         *postgresDatabase
        once                                                sync.Once                                
)

func (p *postgresDatabase) ConnectionGetting() *gorm.DB <span class="cov0" title="0">{
        return p.DB
}</span>

func NewPostgresDatabase(conf *configurations.Database) Database <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                dsn := fmt.Sprintf(
                        "host=%s port=%d user=%s password=%s dbname=%s sslmode=%s search_path=%s",
                        conf.Host, conf.Port, conf.User, conf.Password, conf.DBname, conf.SSLmode, conf.Schema,
                )

                conn, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }

                <span class="cov0" title="0">log.Printf("Connected to database %s", conf.DBname)
                postgreDatebaseInstance = &amp;postgresDatabase{conn}</span>
        })

        <span class="cov0" title="0">return postgreDatebaseInstance</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package alert_events

import (
        "context"
        "log"
        "strconv"
        "time"

        "sun-stockanalysis-api/internal/models"
        "sun-stockanalysis-api/internal/realtime"
        "sun-stockanalysis-api/internal/repository"
)

type AlertEventService interface {
        BuildForSymbol(ctx context.Context, symbol string) error
}

type AlertEventServiceImpl struct {
        quoteRepo repository.StockQuoteRepository
        eventRepo repository.AlertEventRepository
        notifier  realtime.AlertEventNotifier
}

func NewAlertEventService(
        quoteRepo repository.StockQuoteRepository,
        eventRepo repository.AlertEventRepository,
        notifier realtime.AlertEventNotifier,
) AlertEventService <span class="cov0" title="0">{
        return &amp;AlertEventServiceImpl{
                quoteRepo: quoteRepo,
                eventRepo: eventRepo,
                notifier:  notifier,
        }
}</span>

func (s *AlertEventServiceImpl) BuildForSymbol(ctx context.Context, symbol string) error <span class="cov0" title="0">{
        if symbol == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">start, end := dayBoundsBangkok(time.Now())
        quotes, err := s.quoteRepo.FindLatestBySymbolBetween(symbol, start, end, 5)
        if err != nil || len(quotes) &lt; 5 </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">trendEMA20 := 0
        for _, q := range quotes </span><span class="cov0" title="0">{
                trendEMA20 += signFloat(q.ChangeEMA20)
        }</span>
        <span class="cov0" title="0">latest := quotes[0]
        trendTanhEMA := signFloat(latest.ChangeTanhEMA)
        // changeEMA20s := make([]float64, 0, len(quotes))
        // changeEMA20Signs := make([]int, 0, len(quotes))
        // for _, q := range quotes {
        //         changeEMA20s = append(changeEMA20s, q.ChangeEMA20)
        //         changeEMA20Signs = append(changeEMA20Signs, signFloat(q.ChangeEMA20))
        // }
        // log.Printf(
        //         "Start Alert 1.5 symbol=%s trendEMA20=%d trendTanhEMA=%d changeEMA20=%v changeEMA20Signs=%v latestChangeTanhEMA=%.6f",
        //         symbol,
        //         trendEMA20,
        //         trendTanhEMA,
        //         changeEMA20s,
        //         changeEMA20Signs,
        //         latest.ChangeTanhEMA,
        // )
        scoreEMA, ok := scoreFromTrend(trendEMA20, trendTanhEMA)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">log.Printf("ScoreEMA=%d symbol=%s trendEMA20=%d trendTanhEMA=%d", scoreEMA, symbol, trendEMA20, trendTanhEMA)

        scorePCrossEMA := 0
        if latest.PriceCurrent == latest.EMA100 </span><span class="cov0" title="0">{
                scorePCrossEMA = 1
        }</span>

        <span class="cov0" title="0">event := &amp;models.AlertEvent{
                Symbol:         symbol,
                TrendEMA20:     trendEMA20,
                TrendTanhEMA:   trendTanhEMA,
                ScoreEMA:       float64(scoreEMA),
                ScorePCrossEMA: float64(scorePCrossEMA),
        }
        if scoreEMA &gt;= 3 || scoreEMA &lt;= -3 </span><span class="cov0" title="0">{
                if err := s.eventRepo.Create(event); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if s.notifier != nil </span><span class="cov0" title="0">{
                        message := messageForScore(scoreEMA)
                        if message == "" </span><span class="cov0" title="0">{
                                message = "ScoreEMA: " + strconv.Itoa(scoreEMA)
                        }</span>
                        <span class="cov0" title="0">s.notifier.Notify(event, message)</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func dayBoundsBangkok(t time.Time) (time.Time, time.Time) <span class="cov0" title="0">{
        loc := time.FixedZone("Asia/Bangkok", 7*60*60)
        local := t.In(loc)
        start := time.Date(local.Year(), local.Month(), local.Day(), 0, 0, 0, 0, loc)
        end := start.AddDate(0, 0, 1).Add(-time.Nanosecond)
        return start, end
}</span>

func signFloat(v float64) int <span class="cov0" title="0">{
        switch </span>{
        case v &gt; 0:<span class="cov0" title="0">
                return 1</span>
        case v &lt; 0:<span class="cov0" title="0">
                return -1</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

func scoreFromTrend(trendEMA20, trendTanhEMA int) (int, bool) <span class="cov0" title="0">{
        switch </span>{
        case trendEMA20 &lt;= -2:<span class="cov0" title="0">
                switch trendTanhEMA </span>{
                case -1:<span class="cov0" title="0">
                        return -4, true</span>
                case 0, 1:<span class="cov0" title="0">
                        return -3, true</span>
                }
        case trendEMA20 &gt;= 2:<span class="cov0" title="0">
                switch trendTanhEMA </span>{
                case 1:<span class="cov0" title="0">
                        return 4, true</span>
                case 0, -1:<span class="cov0" title="0">
                        return 3, true</span>
                }
        case trendEMA20 == -1:<span class="cov0" title="0">
                switch trendTanhEMA </span>{
                case -1:<span class="cov0" title="0">
                        return -2, true</span>
                case 0, 1:<span class="cov0" title="0">
                        return -1, true</span>
                }
        case trendEMA20 == 1:<span class="cov0" title="0">
                switch trendTanhEMA </span>{
                case 1:<span class="cov0" title="0">
                        return 2, true</span>
                case 0, -1:<span class="cov0" title="0">
                        return 1, true</span>
                }
        }
        <span class="cov0" title="0">return 0, false</span>
}

func messageForScore(scoreEMA int) string <span class="cov0" title="0">{
        switch </span>{
        case scoreEMA &gt;= 3:<span class="cov0" title="0">
                return ""</span>
        case scoreEMA &gt;= 1:<span class="cov0" title="0">
                return "/"</span>
        case scoreEMA &lt;= -3:<span class="cov0" title="0">
                return ""</span>
        case scoreEMA &lt;= -1:<span class="cov0" title="0">
                return "/"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package auth

import (
        "crypto/rand"
        "crypto/sha256"
        "encoding/base64"
        "encoding/hex"
        "errors"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"

        "sun-stockanalysis-api/internal/configurations"
        "sun-stockanalysis-api/internal/models"
        "sun-stockanalysis-api/internal/repository"
)

var (
        ErrInvalidCredentials  = errors.New("invalid credentials")
        ErrEmailAlreadyExists  = errors.New("email already exists")
        ErrInvalidRefreshToken = errors.New("invalid refresh token")
)

const refreshTokenTTL = 7 * 24 * time.Hour

type AuthService interface {
        Login(input LoginInput) (*LoginResult, error)
        Register(input RegisterInput) (*RegisterResult, error)
        Refresh(input RefreshInput) (*LoginResult, error)
}

type AuthServiceImpl struct {
        userRepo         repository.UserRepository
        refreshTokenRepo repository.RefreshTokenRepository
        stateConfig      *configurations.State
}

func NewAuthService(
        userRepo repository.UserRepository,
        refreshTokenRepo repository.RefreshTokenRepository,
        stateConfig *configurations.State,
) AuthService <span class="cov8" title="1">{
        return &amp;AuthServiceImpl{
                userRepo:         userRepo,
                refreshTokenRepo: refreshTokenRepo,
                stateConfig:      stateConfig,
        }
}</span>

func (s *AuthServiceImpl) Login(input LoginInput) (*LoginResult, error) <span class="cov8" title="1">{
        if s.stateConfig == nil || s.stateConfig.Secret == "" </span><span class="cov8" title="1">{
                return nil, errors.New("auth secret not configured")
        }</span>

        <span class="cov8" title="1">user, err := s.userRepo.FindByEmail(input.Body.Email)
        if err != nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidCredentials
        }</span>

        <span class="cov8" title="1">if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(input.Body.Password)); err != nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidCredentials
        }</span>

        <span class="cov8" title="1">accessToken, expiresAt, err := s.createAccessToken(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">refreshToken, refreshTokenHash, refreshExpiresAt, err := newRefreshToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := s.refreshTokenRepo.Create(&amp;models.RefreshTokens{
                UserID:    user.ID.String(),
                TokenHash: refreshTokenHash,
                ExpiresAt: refreshExpiresAt.Format(time.RFC3339),
                RevokedAt: 0,
        }); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">_ = s.userRepo.UpdateLastLogin(user.ID, time.Now())

        return &amp;LoginResult{
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
                ExpiresIn:    int64(time.Until(expiresAt).Seconds()),
        }, nil</span>
}

func (s *AuthServiceImpl) Register(input RegisterInput) (*RegisterResult, error) <span class="cov8" title="1">{
        if input.Body.Email == "" || input.Body.Password == "" </span><span class="cov8" title="1">{
                return nil, errors.New("email and password required")
        }</span>

        <span class="cov8" title="1">exists, err := s.userRepo.ExistsByEmail(input.Body.Email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                return nil, ErrEmailAlreadyExists
        }</span>

        <span class="cov8" title="1">hashed, err := bcrypt.GenerateFromPassword([]byte(input.Body.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">user := &amp;models.User{
                Email:     input.Body.Email,
                Password:  string(hashed),
                FirstName: input.Body.FirstName,
                LastName:  input.Body.LastName,
                Role:      "USER",
        }

        if err := s.userRepo.Create(user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;RegisterResult{UserID: user.ID.String()}, nil</span>
}

func (s *AuthServiceImpl) Refresh(input RefreshInput) (*LoginResult, error) <span class="cov8" title="1">{
        if s.stateConfig == nil || s.stateConfig.Secret == "" </span><span class="cov0" title="0">{
                return nil, errors.New("auth secret not configured")
        }</span>
        <span class="cov8" title="1">if input.Body.RefreshToken == "" </span><span class="cov8" title="1">{
                return nil, ErrInvalidRefreshToken
        }</span>

        <span class="cov8" title="1">hashBytes := sha256.Sum256([]byte(input.Body.RefreshToken))
        hash := hex.EncodeToString(hashBytes[:])

        stored, err := s.refreshTokenRepo.FindByHash(hash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidRefreshToken
        }</span>

        <span class="cov8" title="1">if stored.RevokedAt &gt; 0 </span><span class="cov0" title="0">{
                return nil, ErrInvalidRefreshToken
        }</span>

        <span class="cov8" title="1">expiresAt, err := time.Parse(time.RFC3339, stored.ExpiresAt)
        if err != nil || time.Now().After(expiresAt) </span><span class="cov0" title="0">{
                return nil, ErrInvalidRefreshToken
        }</span>

        <span class="cov8" title="1">userID, err := uuid.Parse(stored.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidRefreshToken
        }</span>

        <span class="cov8" title="1">user, err := s.userRepo.FindByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidRefreshToken
        }</span>

        <span class="cov8" title="1">accessToken, accessExpiresAt, err := s.createAccessToken(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">newRefreshToken, newRefreshTokenHash, newRefreshExpiresAt, err := newRefreshToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := s.refreshTokenRepo.RevokeByHash(hash, float64(time.Now().Unix())); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := s.refreshTokenRepo.Create(&amp;models.RefreshTokens{
                UserID:    user.ID.String(),
                TokenHash: newRefreshTokenHash,
                ExpiresAt: newRefreshExpiresAt.Format(time.RFC3339),
                RevokedAt: 0,
        }); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;LoginResult{
                AccessToken:  accessToken,
                RefreshToken: newRefreshToken,
                ExpiresIn:    int64(time.Until(accessExpiresAt).Seconds()),
        }, nil</span>
}

func (s *AuthServiceImpl) createAccessToken(user *models.User) (string, time.Time, error) <span class="cov8" title="1">{
        expiry := normalizeDuration(s.stateConfig.ExpiredsAt)
        if expiry &lt;= 0 </span><span class="cov0" title="0">{
                expiry = 15 * time.Minute
        }</span>
        <span class="cov8" title="1">expiresAt := time.Now().Add(expiry)

        claims := jwt.RegisteredClaims{
                Subject:   user.ID.String(),
                Issuer:    s.stateConfig.Issuer,
                IssuedAt:  jwt.NewNumericDate(time.Now()),
                ExpiresAt: jwt.NewNumericDate(expiresAt),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "sub":   claims.Subject,
                "iss":   claims.Issuer,
                "iat":   claims.IssuedAt.Unix(),
                "exp":   claims.ExpiresAt.Unix(),
                "email": user.Email,
                "role":  user.Role,
        })

        signed, err := token.SignedString([]byte(s.stateConfig.Secret))
        if err != nil </span><span class="cov0" title="0">{
                return "", time.Time{}, err
        }</span>

        <span class="cov8" title="1">return signed, expiresAt, nil</span>
}

func normalizeDuration(d time.Duration) time.Duration <span class="cov8" title="1">{
        if d &gt; 0 &amp;&amp; d &lt; time.Second </span><span class="cov0" title="0">{
                return d * time.Second
        }</span>
        <span class="cov8" title="1">return d</span>
}

func newRefreshToken() (string, string, time.Time, error) <span class="cov8" title="1">{
        raw := make([]byte, 32)
        if _, err := rand.Read(raw); err != nil </span><span class="cov0" title="0">{
                return "", "", time.Time{}, err
        }</span>
        <span class="cov8" title="1">token := base64.RawURLEncoding.EncodeToString(raw)
        hash := sha256.Sum256([]byte(token))
        return token, hex.EncodeToString(hash[:]), time.Now().Add(refreshTokenTTL), nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package cleanup

import (
        "context"
        "time"

        "sun-stockanalysis-api/internal/repository"
)

type CleanupService interface {
        Start(ctx context.Context)
}

type CleanupServiceImpl struct {
        quoteRepo                  repository.StockQuoteRepository
        companyRepo                repository.CompanyNewsRepository
        alertEventRepo             repository.AlertEventRepository
        marketOpenRepo             repository.MarketOpenRepository
        refreshTokenRepo           repository.RefreshTokenRepository
        pushSubscriptionRepo       repository.PushSubscriptionRepository
        retainDays                 int
        alertRetainDays            int
        marketOpenRetainDays       int
        refreshTokenRetainDays     int
        pushSubscriptionRetainDays int
}

func NewCleanupService(
        quoteRepo repository.StockQuoteRepository,
        companyRepo repository.CompanyNewsRepository,
        alertEventRepo repository.AlertEventRepository,
        marketOpenRepo repository.MarketOpenRepository,
        refreshTokenRepo repository.RefreshTokenRepository,
        pushSubscriptionRepo repository.PushSubscriptionRepository,
        retainDays int,
        alertRetainDays int,
        marketOpenRetainDays int,
        refreshTokenRetainDays int,
        pushSubscriptionRetainDays int,
) CleanupService <span class="cov0" title="0">{
        if retainDays &lt;= 0 </span><span class="cov0" title="0">{
                retainDays = 15
        }</span>
        <span class="cov0" title="0">if alertRetainDays &lt;= 0 </span><span class="cov0" title="0">{
                alertRetainDays = 7
        }</span>
        <span class="cov0" title="0">if marketOpenRetainDays &lt;= 0 </span><span class="cov0" title="0">{
                marketOpenRetainDays = 7
        }</span>
        <span class="cov0" title="0">if refreshTokenRetainDays &lt;= 0 </span><span class="cov0" title="0">{
                refreshTokenRetainDays = 30
        }</span>
        <span class="cov0" title="0">if pushSubscriptionRetainDays &lt;= 0 </span><span class="cov0" title="0">{
                pushSubscriptionRetainDays = 30
        }</span>
        <span class="cov0" title="0">return &amp;CleanupServiceImpl{
                quoteRepo:                  quoteRepo,
                companyRepo:                companyRepo,
                alertEventRepo:             alertEventRepo,
                marketOpenRepo:             marketOpenRepo,
                refreshTokenRepo:           refreshTokenRepo,
                pushSubscriptionRepo:       pushSubscriptionRepo,
                retainDays:                 retainDays,
                alertRetainDays:            alertRetainDays,
                marketOpenRetainDays:       marketOpenRetainDays,
                refreshTokenRetainDays:     refreshTokenRetainDays,
                pushSubscriptionRetainDays: pushSubscriptionRetainDays,
        }</span>
}

func (s *CleanupServiceImpl) Start(ctx context.Context) <span class="cov0" title="0">{
        go s.runScheduler(ctx)
}</span>

func (s *CleanupServiceImpl) runScheduler(ctx context.Context) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                wait := nextRunDuration(0, 5, thailandLocation())
                timer := time.NewTimer(wait)
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        timer.Stop()
                        return</span>
                case &lt;-timer.C:<span class="cov0" title="0"></span>
                }
                <span class="cov0" title="0">s.runOnce(ctx)</span>
        }
}

func (s *CleanupServiceImpl) runOnce(ctx context.Context) <span class="cov0" title="0">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return</span>
        default:<span class="cov0" title="0"></span>
        }
        <span class="cov0" title="0">loc := thailandLocation()
        now := time.Now().In(loc)
        cutoffDate := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, loc).
                AddDate(0, 0, -s.retainDays)
        alertEventCutoffDate := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, loc).
                AddDate(0, 0, -s.alertRetainDays)
        marketOpenCutoffDate := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, loc).
                AddDate(0, 0, -s.marketOpenRetainDays)
        refreshTokenCutoffDate := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, loc).
                AddDate(0, 0, -s.refreshTokenRetainDays)
        pushSubscriptionCutoffDate := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, loc).
                AddDate(0, 0, -s.pushSubscriptionRetainDays)

        if s.quoteRepo != nil </span><span class="cov0" title="0">{
                _ = s.quoteRepo.DeleteBefore(cutoffDate)
        }</span>
        <span class="cov0" title="0">if s.companyRepo != nil </span><span class="cov0" title="0">{
                _ = s.companyRepo.DeleteBefore(cutoffDate)
        }</span>
        <span class="cov0" title="0">if s.alertEventRepo != nil </span><span class="cov0" title="0">{
                _ = s.alertEventRepo.DeleteBefore(alertEventCutoffDate)
        }</span>
        <span class="cov0" title="0">if s.marketOpenRepo != nil </span><span class="cov0" title="0">{
                _ = s.marketOpenRepo.DeleteBefore(marketOpenCutoffDate)
        }</span>
        <span class="cov0" title="0">if s.refreshTokenRepo != nil </span><span class="cov0" title="0">{
                _ = s.refreshTokenRepo.DeleteBefore(refreshTokenCutoffDate)
        }</span>
        <span class="cov0" title="0">if s.pushSubscriptionRepo != nil </span><span class="cov0" title="0">{
                _ = s.pushSubscriptionRepo.DeleteBefore(pushSubscriptionCutoffDate)
        }</span>
}

func nextRunDuration(hour, minute int, loc *time.Location) time.Duration <span class="cov0" title="0">{
        now := time.Now().In(loc)
        next := time.Date(now.Year(), now.Month(), now.Day(), hour, minute, 0, 0, loc)
        if !next.After(now) </span><span class="cov0" title="0">{
                next = next.Add(24 * time.Hour)
        }</span>
        <span class="cov0" title="0">return time.Until(next)</span>
}

func thailandLocation() *time.Location <span class="cov0" title="0">{
        return time.FixedZone("Asia/Bangkok", 7*60*60)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package company_news

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strings"
        "time"

        "sun-stockanalysis-api/internal/models"
        "sun-stockanalysis-api/internal/repository"
        "sun-stockanalysis-api/pkg/logger"
)

const (
        companyNewsURL = "https://finnhub.io/api/v1/company-news"
)

type CompanyNewsService interface {
        Start(ctx context.Context)
        ListBySymbolAndDate(ctx context.Context, symbol string, start, end time.Time) ([]models.CompanyNews, error)
}

type CompanyNewsNotifier interface {
        NotifyCompanyNewsReady(message string)
}

type HTTPClient interface {
        Do(req *http.Request) (*http.Response, error)
}

type CompanyNewsServiceImpl struct {
        relationRepo repository.RelationNewsRepository
        companyRepo  repository.CompanyNewsRepository
        httpClient   HTTPClient
        finnhubToken string
        log          *logger.Logger
        notifier     CompanyNewsNotifier
}

func NewCompanyNewsService(
        relationRepo repository.RelationNewsRepository,
        companyRepo repository.CompanyNewsRepository,
        notifier CompanyNewsNotifier,
        httpClient HTTPClient,
        finnhubToken string,
        log *logger.Logger,
) CompanyNewsService <span class="cov0" title="0">{
        if httpClient == nil </span><span class="cov0" title="0">{
                httpClient = &amp;http.Client{Timeout: 10 * time.Second}
        }</span>
        <span class="cov0" title="0">return &amp;CompanyNewsServiceImpl{
                relationRepo: relationRepo,
                companyRepo:  companyRepo,
                notifier:     notifier,
                httpClient:   httpClient,
                finnhubToken: finnhubToken,
                log:          log,
        }</span>
}

func (s *CompanyNewsServiceImpl) Start(ctx context.Context) <span class="cov0" title="0">{
        go s.runScheduler(ctx)
}</span>

func (s *CompanyNewsServiceImpl) ListBySymbolAndDate(ctx context.Context, symbol string, start, end time.Time) ([]models.CompanyNews, error) <span class="cov0" title="0">{
        if symbol == "" </span><span class="cov0" title="0">{
                return nil, errors.New("symbol is empty")
        }</span>
        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">relations, err := s.relationRepo.ListRelationSymbolsBySymbol(symbol)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(relations) == 0 </span><span class="cov0" title="0">{
                return []models.CompanyNews{}, nil
        }</span>

        <span class="cov0" title="0">return s.companyRepo.FindBySymbolsAndDate(relations, start, end)</span>
}

func (s *CompanyNewsServiceImpl) runScheduler(ctx context.Context) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                wait := nextRunDuration(20, 00, thailandLocation())
                timer := time.NewTimer(wait)
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        timer.Stop()
                        return</span>
                case &lt;-timer.C:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">s.runOnce(ctx)</span>
        }
}

func (s *CompanyNewsServiceImpl) runOnce(ctx context.Context) <span class="cov0" title="0">{
        symbols, err := s.relationRepo.ListDistinctRelationSymbols()
        if err != nil || len(symbols) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">today := time.Now().In(thailandLocation()).Format("2006-01-02")
        if s.log != nil </span><span class="cov0" title="0">{
                s.log.Infof("company_news fetch started: symbols=%d date=%s", len(symbols), today)
        }</span>
        <span class="cov0" title="0">totalSaved := 0
        notifiedToday := false
        for _, symbol := range symbols </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        if s.log != nil </span><span class="cov0" title="0">{
                                s.log.Infof("company_news fetch canceled")
                        }</span>
                        <span class="cov0" title="0">return</span>
                default:<span class="cov0" title="0"></span>
                }
                <span class="cov0" title="0">symbol = strings.TrimSpace(symbol)
                if symbol == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">news, err := s.fetchCompanyNews(symbol, today, today)
                if err != nil || len(news) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">items := make([]models.CompanyNews, 0, len(news))
                for _, n := range news </span><span class="cov0" title="0">{
                        items = append(items, models.CompanyNews{
                                Symbol:   n.Related,
                                Headline: n.Headline,
                                Source:   n.Source,
                                Summary:  n.Summary,
                                Url:      n.URL,
                        })
                }</span>
                <span class="cov0" title="0">if err := s.companyRepo.CreateMany(items); err == nil </span><span class="cov0" title="0">{
                        totalSaved += len(items)
                        if s.notifier != nil &amp;&amp; !notifiedToday </span><span class="cov0" title="0">{
                                s.notifier.NotifyCompanyNewsReady("Today's stock market news is here.")
                                notifiedToday = true
                        }</span>
                }
        }
        <span class="cov0" title="0">if s.log != nil </span><span class="cov0" title="0">{
                s.log.Infof("company_news fetch completed: saved=%d date=%s", totalSaved, today)
        }</span>
}

type finnhubCompanyNewsResponse struct {
        Headline string `json:"headline"`
        Source   string `json:"source"`
        Summary  string `json:"summary"`
        URL      string `json:"url"`
        Related  string `json:"related"`
}

func (s *CompanyNewsServiceImpl) fetchCompanyNews(symbol, fromDate, toDate string) ([]finnhubCompanyNewsResponse, error) <span class="cov0" title="0">{
        reqURL, err := url.Parse(companyNewsURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">q := reqURL.Query()
        q.Set("symbol", symbol)
        q.Set("from", fromDate)
        q.Set("to", toDate)
        reqURL.RawQuery = q.Encode()

        req, err := http.NewRequest(http.MethodGet, reqURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("X-Finnhub-Token", s.finnhubToken)

        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("finnhub company-news request failed: %s", strings.TrimSpace(string(body)))
        }</span>

        <span class="cov0" title="0">var result []finnhubCompanyNewsResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func nextRunDuration(hour, minute int, loc *time.Location) time.Duration <span class="cov0" title="0">{
        now := time.Now().In(loc)
        next := time.Date(now.Year(), now.Month(), now.Day(), hour, minute, 0, 0, loc)
        if !next.After(now) </span><span class="cov0" title="0">{
                next = next.Add(24 * time.Hour)
        }</span>
        <span class="cov0" title="0">return time.Until(next)</span>
}

func thailandLocation() *time.Location <span class="cov0" title="0">{
        return time.FixedZone("Asia/Bangkok", 7*60*60)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package market_open

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "os"
        "strconv"
        "strings"
        "time"

        "gorm.io/gorm"

        "sun-stockanalysis-api/internal/models"
        "sun-stockanalysis-api/internal/repository"
        "sun-stockanalysis-api/pkg/logger"

        "github.com/google/uuid"
)

const (
        defaultMarketStatusURL = "https://finnhub.io/api/v1/stock/market-status?exchange=US"
        defaultPollSeconds     = 60
        defaultStopHour        = 4
        defaultStopMinute      = 30
)

var (
        marketStatusURL = getEnvString("MARKET_STATUS_URL", defaultMarketStatusURL)
        pollInterval    = time.Duration(getEnvInt("MARKET_POLL_SECONDS", defaultPollSeconds)) * time.Second
        stopHour        = getEnvInt("MARKET_STOP_HOUR", defaultStopHour)
        stopMinute      = getEnvInt("MARKET_STOP_MINUTE", defaultStopMinute)
)

type MarketOpenService interface {
        Start(ctx context.Context)
}

type HTTPClient interface {
        Do(req *http.Request) (*http.Response, error)
}

type StockQuoteService interface {
        Start(ctx context.Context)
        RunOnce(ctx context.Context)
        Stop()
}

type StockDailyService interface {
        BuildForWindow(ctx context.Context, start, end time.Time) error
}

type MarketOpenNotifier interface {
        NotifyMarketOpen(message string)
        NotifyMarketClose(message string)
}

type MarketOpenServiceImpl struct {
        repo         repository.MarketOpenRepository
        httpClient   HTTPClient
        finnhubToken string
        quoteService StockQuoteService
        dailyService StockDailyService
        notifier     MarketOpenNotifier
        log          *logger.Logger
}

func NewMarketOpenService(
        repo repository.MarketOpenRepository,
        httpClient HTTPClient,
        finnhubToken string,
        quoteService StockQuoteService,
        dailyService StockDailyService,
        notifier MarketOpenNotifier,
        log *logger.Logger,
) MarketOpenService <span class="cov0" title="0">{
        if httpClient == nil </span><span class="cov0" title="0">{
                httpClient = &amp;http.Client{Timeout: 10 * time.Second}
        }</span>
        <span class="cov0" title="0">return &amp;MarketOpenServiceImpl{
                repo:         repo,
                httpClient:   httpClient,
                finnhubToken: finnhubToken,
                quoteService: quoteService,
                dailyService: dailyService,
                notifier:     notifier,
                log:          log,
        }</span>
}

func (s *MarketOpenServiceImpl) Start(ctx context.Context) <span class="cov0" title="0">{
        go s.runScheduler(ctx)
}</span>

func (s *MarketOpenServiceImpl) runScheduler(ctx context.Context) <span class="cov0" title="0">{
        // TEMP: run immediately on startup.
        // s.runDailyPolling(ctx)

        for </span><span class="cov0" title="0">{
                wait := nextRunDuration(20, 25, time.Local)
                timer := time.NewTimer(wait)
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        timer.Stop()
                        return</span>
                case &lt;-timer.C:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">s.runDailyPolling(ctx)</span>
        }
}

func (s *MarketOpenServiceImpl) runDailyPolling(ctx context.Context) <span class="cov0" title="0">{
        quoteStarted := false
        postHandled := false

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">status, err := s.fetchMarketStatus()
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if status == nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">session := strings.ToLower(strings.TrimSpace(status.session()))
                isOpen := status.isOpen()
                s.logStatus(status)
                switch </span>{
                case session == "pre-market":<span class="cov0" title="0">
                        sleepContext(ctx, pollInterval)
                        continue</span>
                case session == "regular" &amp;&amp; isOpen:<span class="cov0" title="0">
                        _ = s.ensureOpenRecord(status)
                        if s.quoteService != nil &amp;&amp; !quoteStarted </span><span class="cov0" title="0">{
                                s.quoteService.Start(ctx)
                                quoteStarted = true
                                if s.notifier != nil </span><span class="cov0" title="0">{
                                        s.notifier.NotifyMarketOpen("The market is open. Prices are being updated.")
                                }</span>
                        }
                        <span class="cov0" title="0">sleepContext(ctx, pollInterval)
                        continue</span>
                case session == "post-market" || (session == "regular" &amp;&amp; !isOpen):<span class="cov0" title="0">
                        _ = s.updateCloseRecord(status)
                        if s.quoteService != nil &amp;&amp; !postHandled </span><span class="cov0" title="0">{
                                s.quoteService.RunOnce(ctx)
                                s.quoteService.Stop()
                                postHandled = true
                                if s.notifier != nil </span><span class="cov0" title="0">{
                                        s.notifier.NotifyMarketClose("")
                                }</span>
                                <span class="cov0" title="0">if s.dailyService != nil </span><span class="cov0" title="0">{
                                        start, end := metricsWindow(time.Now())
                                        _ = s.dailyService.BuildForWindow(ctx, start, end)
                                }</span>
                        }
                        <span class="cov0" title="0">sleepContext(ctx, pollInterval)
                        continue</span>
                default:<span class="cov0" title="0">
                        if shouldStopForDay(time.Now()) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">sleepContext(ctx, pollInterval)
                        continue</span>
                }
        }
}

func (s *MarketOpenServiceImpl) logStatus(status *finnhubMarketStatusResponse) <span class="cov0" title="0">{
        correlationID := uuid.NewString()
        session := ""
        exchange := ""
        isOpen := false
        timestamp := int64(0)
        timezone := ""
        if status != nil </span><span class="cov0" title="0">{
                session = status.session()
                exchange = status.Exchange
                isOpen = status.IsOpen
                timestamp = status.T
                timezone = status.Timezone
        }</span>
        <span class="cov0" title="0">message := fmt.Sprintf("market status: session=%s exchange=%s isOpen=%t t=%d timezone=%s",
                session,
                exchange,
                isOpen,
                timestamp,
                timezone,
        )
        if s.log != nil </span><span class="cov0" title="0">{
                s.log.With("correlation_id", correlationID).Infof(message)
                return
        }</span>
        <span class="cov0" title="0">_ = correlationID</span>
}

type finnhubMarketStatusResponse struct {
        Exchange string  `json:"exchange"`
        Holiday  *string `json:"holiday"`
        IsOpen   bool    `json:"isOpen"`
        Session  *string `json:"session"`
        T        int64   `json:"t"`
        Timezone string  `json:"timezone"`
}

func (r *finnhubMarketStatusResponse) session() string <span class="cov0" title="0">{
        if r == nil || r.Session == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return *r.Session</span>
}

func (r *finnhubMarketStatusResponse) isOpen() bool <span class="cov0" title="0">{
        if r == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return r.IsOpen</span>
}

func (s *MarketOpenServiceImpl) fetchMarketStatus() (*finnhubMarketStatusResponse, error) <span class="cov0" title="0">{
        req, err := http.NewRequest(http.MethodGet, marketStatusURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("X-Finnhub-Token", s.finnhubToken)

        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("finnhub market-status request failed: %s", strings.TrimSpace(string(body)))
        }</span>

        <span class="cov0" title="0">var result *finnhubMarketStatusResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (s *MarketOpenServiceImpl) ensureOpenRecord(status *finnhubMarketStatusResponse) error <span class="cov0" title="0">{
        tradeDate, openAt := tradeDateAndTime(status)
        tradeDate = tradeDateForMarketWindow(openAt)
        _, err := s.repo.FindByTradeDate(tradeDate)
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">record := &amp;models.MarketOpen{
                TradeDate:    models.NewLocalDate(tradeDate),
                IsTradingDay: true,
                OpenAt:       models.NewLocalTime(openAt),
        }
        return s.repo.Create(record)</span>
}

func (s *MarketOpenServiceImpl) updateCloseRecord(status *finnhubMarketStatusResponse) error <span class="cov0" title="0">{
        tradeDate, closeAt := tradeDateAndTime(status)
        tradeDate = tradeDateForMarketWindow(closeAt)
        record, err := s.repo.FindByTradeDate(tradeDate)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">return s.repo.UpdateCloseAt(record.ID, closeAt, false)</span>
}

func tradeDateAndTime(status *finnhubMarketStatusResponse) (time.Time, time.Time) <span class="cov0" title="0">{
        if status == nil </span><span class="cov0" title="0">{
                now := time.Now()
                date := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, now.Location())
                return date, now
        }</span>

        <span class="cov0" title="0">loc := time.FixedZone("Asia/Bangkok", 7*60*60)
        timestamp := status.T
        if timestamp &lt;= 0 </span><span class="cov0" title="0">{
                now := time.Now().In(loc)
                date := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, loc)
                return date, now
        }</span>

        <span class="cov0" title="0">at := time.Unix(timestamp, 0).In(loc)
        date := time.Date(at.Year(), at.Month(), at.Day(), 0, 0, 0, 0, loc)
        return date, at</span>
}

func tradeDateForMarketWindow(at time.Time) time.Time <span class="cov0" title="0">{
        loc := time.FixedZone("Asia/Bangkok", 7*60*60)
        t := at.In(loc)
        date := time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, loc)
        if t.Hour() &lt; 4 </span><span class="cov0" title="0">{
                return date.AddDate(0, 0, -1)
        }</span>
        <span class="cov0" title="0">return date</span>
}

func shouldStopForDay(now time.Time) bool <span class="cov0" title="0">{
        loc := time.FixedZone("Asia/Bangkok", 7*60*60)
        current := now.In(loc)
        stopAt := time.Date(current.Year(), current.Month(), current.Day(), stopHour, stopMinute, 0, 0, loc)
        return !current.Before(stopAt)
}</span>

func metricsWindow(now time.Time) (time.Time, time.Time) <span class="cov0" title="0">{
        loc := time.FixedZone("Asia/Bangkok", 7*60*60)
        current := now.In(loc)
        start := time.Date(current.Year(), current.Month(), current.Day(), 20, 0, 0, 0, loc).Add(-24 * time.Hour)
        end := time.Date(current.Year(), current.Month(), current.Day(), 4, 30, 0, 0, loc)
        return start, end
}</span>

func nextRunDuration(hour, minute int, loc *time.Location) time.Duration <span class="cov0" title="0">{
        now := time.Now().In(loc)
        next := time.Date(now.Year(), now.Month(), now.Day(), hour, minute, 0, 0, loc)
        if !next.After(now) </span><span class="cov0" title="0">{
                next = next.Add(24 * time.Hour)
        }</span>
        <span class="cov0" title="0">return time.Until(next)</span>
}

func sleepContext(ctx context.Context, d time.Duration) <span class="cov0" title="0">{
        timer := time.NewTimer(d)
        defer timer.Stop()
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0"></span>
        case &lt;-timer.C:<span class="cov0" title="0"></span>
        }
}

func getEnvString(key, fallback string) string <span class="cov0" title="0">{
        if v := strings.TrimSpace(os.Getenv(key)); v != "" </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov0" title="0">return fallback</span>
}

func getEnvInt(key string, fallback int) int <span class="cov0" title="0">{
        raw := strings.TrimSpace(os.Getenv(key))
        if raw == "" </span><span class="cov0" title="0">{
                return fallback
        }</span>
        <span class="cov0" title="0">n, err := strconv.Atoi(raw)
        if err != nil || n &lt; 0 </span><span class="cov0" title="0">{
                return fallback
        }</span>
        <span class="cov0" title="0">return n</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package push_subscriptions

import (
        "context"
        "encoding/json"
        "errors"
        "log"
        "net/http"
        "strings"

        "github.com/SherClockHolmes/webpush-go"
        "github.com/google/uuid"

        "sun-stockanalysis-api/internal/configurations"
        "sun-stockanalysis-api/internal/models"
        "sun-stockanalysis-api/internal/repository"
)

type SaveSubscriptionInput struct {
        DeviceID  string
        Endpoint  string
        P256DHKey string
        AuthKey   string
        UserAgent string
}

type PushSubscriptionService interface {
        GetPublicKey(ctx context.Context) (string, error)
        Save(ctx context.Context, userID string, input SaveSubscriptionInput) error
        Delete(ctx context.Context, userID, deviceID string) error
        Notify(event *models.AlertEvent, message string)
        NotifyCompanyNewsReady(message string)
        NotifyMarketOpen(message string)
        NotifyMarketClose(message string)
}

type PushSubscriptionServiceImpl struct {
        subRepo        repository.PushSubscriptionRepository
        vapidPublicKey string
        vapidPrivate   string
        subject        string
        triggerScore   int
}

func NewPushSubscriptionService(
        subRepo repository.PushSubscriptionRepository,
        pushCfg *configurations.Push,
) (PushSubscriptionService, error) <span class="cov0" title="0">{
        if subRepo == nil </span><span class="cov0" title="0">{
                return nil, errors.New("push subscription repository is required")
        }</span>

        <span class="cov0" title="0">service := &amp;PushSubscriptionServiceImpl{
                subRepo:      subRepo,
                subject:      "mailto:admin@example.com",
                triggerScore: 4,
        }

        if pushCfg != nil </span><span class="cov0" title="0">{
                if strings.TrimSpace(pushCfg.Subject) != "" </span><span class="cov0" title="0">{
                        service.subject = strings.TrimSpace(pushCfg.Subject)
                }</span>
                <span class="cov0" title="0">if pushCfg.TriggerScore &gt; 0 </span><span class="cov0" title="0">{
                        service.triggerScore = pushCfg.TriggerScore
                }</span>
                <span class="cov0" title="0">service.vapidPublicKey = strings.TrimSpace(pushCfg.VAPIDPublicKey)
                service.vapidPrivate = strings.TrimSpace(pushCfg.VAPIDPrivateKey)</span>
        }

        <span class="cov0" title="0">if err := service.ensureVAPIDKeys(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return service, nil</span>
}

func (s *PushSubscriptionServiceImpl) GetPublicKey(ctx context.Context) (string, error) <span class="cov0" title="0">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return "", ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }
        <span class="cov0" title="0">if s.vapidPublicKey == "" </span><span class="cov0" title="0">{
                return "", errors.New("vapid public key is not configured")
        }</span>
        <span class="cov0" title="0">return s.vapidPublicKey, nil</span>
}

func (s *PushSubscriptionServiceImpl) Save(ctx context.Context, userID string, input SaveSubscriptionInput) error <span class="cov0" title="0">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }
        <span class="cov0" title="0">if strings.TrimSpace(userID) == "" </span><span class="cov0" title="0">{
                return errors.New("user id is required")
        }</span>
        <span class="cov0" title="0">userUUID, err := uuid.Parse(strings.TrimSpace(userID))
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("invalid user id")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(input.DeviceID) == "" </span><span class="cov0" title="0">{
                return errors.New("device_id is required")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(input.Endpoint) == "" </span><span class="cov0" title="0">{
                return errors.New("subscription endpoint is required")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(input.P256DHKey) == "" || strings.TrimSpace(input.AuthKey) == "" </span><span class="cov0" title="0">{
                return errors.New("subscription keys are required")
        }</span>

        <span class="cov0" title="0">return s.subRepo.Upsert(&amp;models.PushSubscription{
                UserID:    userUUID,
                DeviceID:  strings.TrimSpace(input.DeviceID),
                Endpoint:  strings.TrimSpace(input.Endpoint),
                P256DHKey: strings.TrimSpace(input.P256DHKey),
                AuthKey:   strings.TrimSpace(input.AuthKey),
                UserAgent: strings.TrimSpace(input.UserAgent),
                IsActive:  true,
        })</span>
}

func (s *PushSubscriptionServiceImpl) Delete(ctx context.Context, userID, deviceID string) error <span class="cov0" title="0">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }
        <span class="cov0" title="0">if strings.TrimSpace(userID) == "" </span><span class="cov0" title="0">{
                return errors.New("user id is required")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(deviceID) == "" </span><span class="cov0" title="0">{
                return errors.New("device_id is required")
        }</span>

        <span class="cov0" title="0">userUUID, err := uuid.Parse(strings.TrimSpace(userID))
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("invalid user id")
        }</span>
        <span class="cov0" title="0">return s.subRepo.DeleteByUserAndDevice(userUUID, strings.TrimSpace(deviceID))</span>
}

func (s *PushSubscriptionServiceImpl) Notify(event *models.AlertEvent, message string) <span class="cov0" title="0">{
        if event == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">score := int(event.ScoreEMA)
        if score != s.triggerScore &amp;&amp; score != -s.triggerScore </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">payload, err := s.buildPopupPayload("Stock Alert", event, message)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">s.sendToSubscriptions(payload)</span>
}

func (s *PushSubscriptionServiceImpl) NotifyCompanyNewsReady(message string) <span class="cov0" title="0">{
        if strings.TrimSpace(message) == "" </span><span class="cov0" title="0">{
                message = ""
        }</span>
        <span class="cov0" title="0">payload, err := s.buildPopupPayload("Company News", nil, message)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">s.sendToSubscriptions(payload)</span>
}

func (s *PushSubscriptionServiceImpl) NotifyMarketOpen(message string) <span class="cov0" title="0">{
        if strings.TrimSpace(message) == "" </span><span class="cov0" title="0">{
                message = ""
        }</span>
        <span class="cov0" title="0">payload, err := s.buildPopupPayload("Market Open", nil, message)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">s.sendToSubscriptions(payload)</span>
}

func (s *PushSubscriptionServiceImpl) NotifyMarketClose(message string) <span class="cov0" title="0">{
        if strings.TrimSpace(message) == "" </span><span class="cov0" title="0">{
                message = ""
        }</span>
        <span class="cov0" title="0">payload, err := s.buildPopupPayload("Market Close", nil, message)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">s.sendToSubscriptions(payload)</span>
}

func (s *PushSubscriptionServiceImpl) buildPopupPayload(title string, event *models.AlertEvent, message string) ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(struct {
                Type    string             `json:"type"`
                Title   string             `json:"title"`
                Event   *models.AlertEvent `json:"event"`
                Message string             `json:"message"`
        }{
                Type:    "popup",
                Title:   title,
                Event:   event,
                Message: message,
        })
}</span>

func (s *PushSubscriptionServiceImpl) sendToSubscriptions(payload []byte) <span class="cov0" title="0">{
        subscriptions, err := s.subRepo.ListActive()
        if err != nil || len(subscriptions) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for _, sub := range subscriptions </span><span class="cov0" title="0">{
                resp, sendErr := webpush.SendNotification(payload, &amp;webpush.Subscription{
                        Endpoint: sub.Endpoint,
                        Keys: webpush.Keys{
                                Auth:   sub.AuthKey,
                                P256dh: sub.P256DHKey,
                        },
                }, &amp;webpush.Options{
                        Subscriber:      s.subject,
                        VAPIDPublicKey:  s.vapidPublicKey,
                        VAPIDPrivateKey: s.vapidPrivate,
                        TTL:             30,
                })
                if resp != nil </span><span class="cov0" title="0">{
                        _ = resp.Body.Close()
                        if resp.StatusCode == http.StatusNotFound || resp.StatusCode == http.StatusGone </span><span class="cov0" title="0">{
                                _ = s.subRepo.DeleteByEndpoint(sub.Endpoint)
                        }</span>
                }
                <span class="cov0" title="0">if sendErr != nil </span><span class="cov0" title="0">{
                        log.Printf("push notify failed endpoint=%s err=%v", sub.Endpoint, sendErr)
                }</span>
        }
}

func (s *PushSubscriptionServiceImpl) ensureVAPIDKeys() error <span class="cov0" title="0">{
        if s.vapidPublicKey == "" </span><span class="cov0" title="0">{
                return errors.New("PUSH_VAPIDPUBLICKEY is required")
        }</span>
        <span class="cov0" title="0">if s.vapidPrivate == "" </span><span class="cov0" title="0">{
                return errors.New("PUSH_VAPIDPRIVATEKEY is required")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package relation_news

import (
        "errors"
        "strings"

        "sun-stockanalysis-api/internal/models"
        "sun-stockanalysis-api/internal/repository"
)

type RelationNewsService interface {
        CreateRelations(symbol string, relationSymbols []string) error
}

type RelationNewsServiceImpl struct {
        repo repository.RelationNewsRepository
}

func NewRelationNewsService(repo repository.RelationNewsRepository) RelationNewsService <span class="cov0" title="0">{
        return &amp;RelationNewsServiceImpl{repo: repo}
}</span>

func (s *RelationNewsServiceImpl) CreateRelations(symbol string, relationSymbols []string) error <span class="cov0" title="0">{
        base := strings.TrimSpace(symbol)
        if base == "" </span><span class="cov0" title="0">{
                return errors.New("symbol is required")
        }</span>

        <span class="cov0" title="0">unique := map[string]struct{}{}
        unique[base] = struct{}{}
        for _, rel := range relationSymbols </span><span class="cov0" title="0">{
                rel = strings.TrimSpace(rel)
                if rel == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">unique[rel] = struct{}{}</span>
        }

        <span class="cov0" title="0">items := make([]models.RelationNews, 0, len(unique))
        for rel := range unique </span><span class="cov0" title="0">{
                items = append(items, models.RelationNews{
                        Symbol:         base,
                        RelationSymbol: rel,
                        IsActive:       true,
                })
        }</span>

        <span class="cov0" title="0">return s.repo.CreateMany(items)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package stock

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"

        "github.com/google/uuid"

        "sun-stockanalysis-api/internal/models"
        "sun-stockanalysis-api/internal/repository"
)

type StockService interface {
        GetStock(id uuid.UUID) (*models.Stock, error)
        CreateStock(input CreateStockInput) error
        ListAll() ([]models.Stock, error)
}

type HTTPClient interface {
        Do(req *http.Request) (*http.Response, error)
}

type StockServiceImpl struct {
        repo         repository.StockRepository
        httpClient   HTTPClient
        finnhubToken string
}

func NewStockService(repo repository.StockRepository, httpClient HTTPClient, finnhubToken string) StockService <span class="cov0" title="0">{
        if httpClient == nil </span><span class="cov0" title="0">{
                httpClient = &amp;http.Client{Timeout: 10 * time.Second}
        }</span>
        <span class="cov0" title="0">return &amp;StockServiceImpl{
                repo:         repo,
                httpClient:   httpClient,
                finnhubToken: finnhubToken,
        }</span>
}

func (s *StockServiceImpl) GetStock(id uuid.UUID) (*models.Stock, error) <span class="cov0" title="0">{
        return s.repo.FindByID(id)
}</span>

func (s *StockServiceImpl) CreateStock(input CreateStockInput) error <span class="cov0" title="0">{
        profile, err := s.fetchProfile(input.Body.Symbol)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">assetType, err := s.fetchAssetType(input.Body.Symbol)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if profile.Exchange != "" </span><span class="cov0" title="0">{
                if err := s.repo.EnsureMasterExchange(profile.Exchange); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if profile.FinnhubIndustry != "" </span><span class="cov0" title="0">{
                if err := s.repo.EnsureMasterSector(profile.FinnhubIndustry); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if assetType != "" </span><span class="cov0" title="0">{
                if err := s.repo.EnsureMasterAssetType(assetType); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">symbol := profile.Symbol
        if symbol == "" </span><span class="cov0" title="0">{
                symbol = input.Body.Symbol
        }</span>

        <span class="cov0" title="0">return s.repo.Create(&amp;models.Stock{
                Symbol:    symbol,
                Name:      profile.Name,
                Sector:    profile.FinnhubIndustry,
                Exchange:  profile.Exchange,
                AssetType: assetType,
                Currency:  profile.Currency,
        })</span>
}

func (s *StockServiceImpl) ListAll() ([]models.Stock, error) <span class="cov0" title="0">{
        return s.repo.FindAll()
}</span>

type finnhubProfileResponse struct {
        Exchange        string `json:"exchange"`
        FinnhubIndustry string `json:"finnhubIndustry"`
        Currency        string `json:"currency"`
        Name            string `json:"name"`
        Symbol          string `json:"symbol"`
}

type finnhubSearchResponse struct {
        Count  int `json:"count"`
        Result []struct {
                Symbol string `json:"symbol"`
                Type   string `json:"type"`
        } `json:"result"`
}

func (s *StockServiceImpl) fetchProfile(symbol string) (*finnhubProfileResponse, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("https://finnhub.io/api/v1/stock/profile2?symbol=%s", symbol)
        req, err := http.NewRequest(http.MethodGet, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("X-Finnhub-Token", s.finnhubToken)

        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("finnhub profile request failed: %s", strings.TrimSpace(string(body)))
        }</span>

        <span class="cov0" title="0">var result finnhubProfileResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;result, nil</span>
}

func (s *StockServiceImpl) fetchAssetType(symbol string) (string, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("https://finnhub.io/api/v1/search?q=%s&amp;exchange=US", symbol)
        req, err := http.NewRequest(http.MethodGet, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">req.Header.Set("X-Finnhub-Token", s.finnhubToken)

        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return "", fmt.Errorf("finnhub search request failed: %s", strings.TrimSpace(string(body)))
        }</span>

        <span class="cov0" title="0">var result finnhubSearchResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">for _, item := range result.Result </span><span class="cov0" title="0">{
                if strings.EqualFold(item.Symbol, symbol) </span><span class="cov0" title="0">{
                        return item.Type, nil
                }</span>
        }
        <span class="cov0" title="0">if len(result.Result) &gt; 0 </span><span class="cov0" title="0">{
                return result.Result[0].Type, nil
        }</span>
        <span class="cov0" title="0">return "", nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package stock_daily

import (
        "context"
        "errors"
        "os"
        "strconv"
        "strings"
        "time"

        "gorm.io/gorm"

        "sun-stockanalysis-api/internal/models"
        "sun-stockanalysis-api/internal/repository"
)

const (
        defaultEMAPeriod20  = 20
        defaultEMAPeriod100 = 100
)

var (
        emaPeriod20  = getEnvInt("STOCK_DAILY_EMA_PERIOD20", defaultEMAPeriod20)
        emaPeriod100 = getEnvInt("STOCK_DAILY_EMA_PERIOD100", defaultEMAPeriod100)
)

type StockDailyService interface {
        BuildForWindow(ctx context.Context, start, end time.Time) error
        ListBySymbol(ctx context.Context, symbol string) ([]models.StockDaily, error)
}

type StockDailyServiceImpl struct {
        stockRepo  repository.StockRepository
        quoteRepo  repository.StockQuoteRepository
        metricRepo repository.StockDailyRepository
}

func NewStockDailyService(
        stockRepo repository.StockRepository,
        quoteRepo repository.StockQuoteRepository,
        metricRepo repository.StockDailyRepository,
) StockDailyService <span class="cov0" title="0">{
        return &amp;StockDailyServiceImpl{
                stockRepo:  stockRepo,
                quoteRepo:  quoteRepo,
                metricRepo: metricRepo,
        }
}</span>

func (s *StockDailyServiceImpl) BuildForWindow(ctx context.Context, start, end time.Time) error <span class="cov0" title="0">{
        symbols, err := s.stockRepo.ListSymbols()
        if err != nil || len(symbols) == 0 </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">tradeDate := tradeDateFromEnd(end)

        for _, symbol := range symbols </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">quotes, err := s.quoteRepo.FindBySymbolBetween(symbol, start, end)
                if err != nil || len(quotes) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">first := quotes[0]
                last := quotes[len(quotes)-1]

                avg, high, low := summarizePrices(quotes)

                ema20 := s.calculateEMA(symbol, last.PriceCurrent, emaPeriod20)
                ema100 := s.calculateEMA(symbol, last.PriceCurrent, emaPeriod100)
                emaTrend := 0
                if ema20 &gt; ema100 </span><span class="cov0" title="0">{
                        emaTrend = 1
                }</span> else<span class="cov0" title="0"> if ema20 &lt; ema100 </span><span class="cov0" title="0">{
                        emaTrend = -1
                }</span> else<span class="cov0" title="0"> if ema20 == ema100 </span><span class="cov0" title="0">{
                        emaTrend = 0
                }</span>

                <span class="cov0" title="0">metric := &amp;models.StockDaily{
                        Symbol:         symbol,
                        PriceAverage:   avg,
                        PriceHigh:      high,
                        PriceLow:       low,
                        PriceOpen:      first.PriceCurrent,
                        PricePrevClose: last.PriceCurrent,
                        ChangePrice:    last.ChangePrice,
                        ChangePercent:  last.ChangePercent,
                        DeltaPrice:     high - low,
                        EMA20:          ema20,
                        EMA100:         ema100,
                        TradeDate:      tradeDate,
                        EMATrend:       emaTrend,
                }

                if err := s.metricRepo.Create(metric); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *StockDailyServiceImpl) ListBySymbol(ctx context.Context, symbol string) ([]models.StockDaily, error) <span class="cov0" title="0">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }
        <span class="cov0" title="0">symbol = strings.TrimSpace(symbol)
        if symbol == "" </span><span class="cov0" title="0">{
                return nil, errors.New("symbol is empty")
        }</span>
        <span class="cov0" title="0">return s.metricRepo.FindPreviousBySymbol(symbol)</span>
}

func (s *StockDailyServiceImpl) calculateEMA(symbol string, current float64, period int) float64 <span class="cov0" title="0">{
        if period &lt;= 1 </span><span class="cov0" title="0">{
                return current
        }</span>
        <span class="cov0" title="0">prev, err := s.metricRepo.FindLatestBySymbol(symbol)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return current
                }</span>
                <span class="cov0" title="0">return current</span>
        }
        <span class="cov0" title="0">if prev == nil </span><span class="cov0" title="0">{
                return current
        }</span>
        <span class="cov0" title="0">emaPrev := current
        switch period </span>{
        case emaPeriod20:<span class="cov0" title="0">
                emaPrev = prev.EMA20</span>
        case emaPeriod100:<span class="cov0" title="0">
                emaPrev = prev.EMA100</span>
        }

        <span class="cov0" title="0">alpha := 2.0 / float64(period-1)
        return alpha*current + (1-alpha)*emaPrev</span>
}

func summarizePrices(quotes []models.StockQuote) (avg float64, high float64, low float64) <span class="cov0" title="0">{
        if len(quotes) == 0 </span><span class="cov0" title="0">{
                return 0, 0, 0
        }</span>
        <span class="cov0" title="0">sum := 0.0
        high = quotes[0].PriceCurrent
        low = quotes[0].PriceCurrent
        for _, q := range quotes </span><span class="cov0" title="0">{
                price := q.PriceCurrent
                sum += price
                if price &gt; high </span><span class="cov0" title="0">{
                        high = price
                }</span>
                <span class="cov0" title="0">if price &lt; low </span><span class="cov0" title="0">{
                        low = price
                }</span>
        }
        <span class="cov0" title="0">avg = sum / float64(len(quotes))
        return avg, high, low</span>
}

func tradeDateFromEnd(end time.Time) models.LocalDate <span class="cov0" title="0">{
        loc := time.FixedZone("Asia/Bangkok", 7*60*60)
        endLocal := end.In(loc)
        yesterday := endLocal.AddDate(0, 0, -1)
        date := time.Date(yesterday.Year(), yesterday.Month(), yesterday.Day(), 0, 0, 0, 0, loc)
        return models.NewLocalDate(date)
}</span>

func getEnvInt(key string, fallback int) int <span class="cov0" title="0">{
        raw := strings.TrimSpace(os.Getenv(key))
        if raw == "" </span><span class="cov0" title="0">{
                return fallback
        }</span>
        <span class="cov0" title="0">n, err := strconv.Atoi(raw)
        if err != nil || n &lt;= 0 </span><span class="cov0" title="0">{
                return fallback
        }</span>
        <span class="cov0" title="0">return n</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package stock_quotes

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "math"
        "net/http"
        "net/url"
        "os"
        "strconv"
        "strings"
        "sync"
        "time"

        "gorm.io/gorm"

        "sun-stockanalysis-api/internal/domains/alert_events"
        "sun-stockanalysis-api/internal/models"
        "sun-stockanalysis-api/internal/realtime"
        "sun-stockanalysis-api/internal/repository"
)

const (
        defaultQuoteURL        = "https://finnhub.io/api/v1/quote"
        defaultQuotePollSec    = 60
        defaultQuoteTimeoutSec = 10
        defaultEMAPeriod20     = 20
        defaultEMAPeriod100    = 100
)

var (
        quoteURL     = getEnvString("QUOTE_URL", defaultQuoteURL)
        quotePoll    = time.Duration(getEnvInt("QUOTE_POLL_SECONDS", defaultQuotePollSec)) * time.Second
        quoteTimeout = time.Duration(getEnvInt("QUOTE_TIMEOUT_SECONDS", defaultQuoteTimeoutSec)) * time.Second
        emaPeriod20  = getEnvInt("EMA_PERIOD20", defaultEMAPeriod20)
        emaPeriod100 = getEnvInt("EMA_PERIOD100", defaultEMAPeriod100)
)

type StockQuoteService interface {
        Start(ctx context.Context)
        RunOnce(ctx context.Context)
        Stop()
        List(ctx context.Context, symbol string) ([]models.StockQuote, error)
}

type HTTPClient interface {
        Do(req *http.Request) (*http.Response, error)
}

type StockQuoteServiceImpl struct {
        stockRepo     repository.StockRepository
        quoteRepo     repository.StockQuoteRepository
        alertService  alert_events.AlertEventService
        notifier      realtime.StockQuoteNotifier
        httpClient    HTTPClient
        finnhubToken  string
        pollInterval  time.Duration
        requestTimout time.Duration
        mu            sync.Mutex
        cancel        context.CancelFunc
}

func NewStockQuoteService(
        stockRepo repository.StockRepository,
        quoteRepo repository.StockQuoteRepository,
        alertService alert_events.AlertEventService,
        notifier realtime.StockQuoteNotifier,
        httpClient HTTPClient,
        finnhubToken string,
) StockQuoteService <span class="cov0" title="0">{
        if httpClient == nil </span><span class="cov0" title="0">{
                httpClient = &amp;http.Client{Timeout: quoteTimeout}
        }</span>
        <span class="cov0" title="0">return &amp;StockQuoteServiceImpl{
                stockRepo:     stockRepo,
                quoteRepo:     quoteRepo,
                alertService:  alertService,
                notifier:      notifier,
                httpClient:    httpClient,
                finnhubToken:  finnhubToken,
                pollInterval:  quotePoll,
                requestTimout: quoteTimeout,
        }</span>
}

func (s *StockQuoteServiceImpl) Start(ctx context.Context) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.cancel != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">runCtx, cancel := context.WithCancel(ctx)
        s.cancel = cancel
        go s.run(runCtx)</span>
}

func (s *StockQuoteServiceImpl) Stop() <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.cancel == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">s.cancel()
        s.cancel = nil</span>
}

func (s *StockQuoteServiceImpl) RunOnce(ctx context.Context) <span class="cov0" title="0">{
        s.fetchAndStoreAll(ctx)
}</span>

func (s *StockQuoteServiceImpl) List(ctx context.Context, symbol string) ([]models.StockQuote, error) <span class="cov0" title="0">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }
        <span class="cov0" title="0">if strings.TrimSpace(symbol) == "" </span><span class="cov0" title="0">{
                return s.quoteRepo.FindAll()
        }</span>
        <span class="cov0" title="0">return s.quoteRepo.FindBySymbol(strings.TrimSpace(symbol))</span>
}

func (s *StockQuoteServiceImpl) run(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(s.pollInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0"></span>
                }
                <span class="cov0" title="0">s.fetchAndStoreAll(ctx)</span>
        }
}

type finnhubQuoteResponse struct {
        C  float64 `json:"c"`
        D  float64 `json:"d"`
        DP float64 `json:"dp"`
        H  float64 `json:"h"`
        L  float64 `json:"l"`
        O  float64 `json:"o"`
        PC float64 `json:"pc"`
        T  int64   `json:"t"`
}

func (s *StockQuoteServiceImpl) fetchQuote(symbol string) (*finnhubQuoteResponse, error) <span class="cov0" title="0">{
        reqURL, err := url.Parse(quoteURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">q := reqURL.Query()
        q.Set("symbol", symbol)
        reqURL.RawQuery = q.Encode()

        req, err := http.NewRequest(http.MethodGet, reqURL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("X-Finnhub-Token", s.finnhubToken)

        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("finnhub quote request failed: %s", strings.TrimSpace(string(body)))
        }</span>

        <span class="cov0" title="0">var result *finnhubQuoteResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (s *StockQuoteServiceImpl) fetchAndStoreAll(ctx context.Context) <span class="cov0" title="0">{
        symbols, err := s.stockRepo.ListSymbols()
        if err != nil || len(symbols) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for _, symbol := range symbols </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0"></span>
                }
                <span class="cov0" title="0">symbol = strings.TrimSpace(symbol)
                if symbol == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">quote, err := s.fetchQuote(symbol)
                if err != nil || quote == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">prev, err := s.quoteRepo.FindLatestBySymbol(symbol)
                if err != nil &amp;&amp; !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">ema20 := s.calculateEMA(quote.C, emaPeriod20, prev)
                ema100 := s.calculateEMA(quote.C, emaPeriod100, prev)
                tanhEMA := math.Tanh(ema20-ema100) / 5.0
                changeEMA20 := 0.0
                changeTanhEMA := 0.0
                emaTrend := 0
                if ema20 &gt; ema100 </span><span class="cov0" title="0">{
                        emaTrend = 1
                }</span> else<span class="cov0" title="0"> if ema20 &lt; ema100 </span><span class="cov0" title="0">{
                        emaTrend = -1
                }</span> else<span class="cov0" title="0"> if ema20 == ema100 </span><span class="cov0" title="0">{
                        emaTrend = 0
                }</span>
                <span class="cov0" title="0">if prev != nil </span><span class="cov0" title="0">{
                        changeEMA20 = ema20 - prev.EMA20
                        changeTanhEMA = tanhEMA - prev.TanhEMA
                }</span>
                <span class="cov0" title="0">createdAt := time.Now().In(time.FixedZone("Asia/Bangkok", 7*60*60)).Truncate(time.Minute)
                changePrice := quote.D
                changePercent := quote.DP
                newQuote := &amp;models.StockQuote{
                        Symbol:        symbol,
                        PriceCurrent:  quote.C,
                        ChangePrice:   &amp;changePrice,
                        ChangePercent: &amp;changePercent,
                        EMA20:         ema20,
                        EMA100:        ema100,
                        TanhEMA:       tanhEMA,
                        ChangeEMA20:   changeEMA20,
                        ChangeTanhEMA: changeTanhEMA,
                        EMATrend:      emaTrend,
                        CreatedAt:     models.NewLocalTime(createdAt.Truncate(time.Minute)),
                }
                if err := s.quoteRepo.Create(newQuote); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if s.notifier != nil </span><span class="cov0" title="0">{
                        s.notifier.NotifyQuote(newQuote)
                }</span>
                <span class="cov0" title="0">if s.alertService != nil </span><span class="cov0" title="0">{
                        _ = s.alertService.BuildForSymbol(ctx, symbol)
                }</span>
        }
}

func (s *StockQuoteServiceImpl) calculateEMA(current float64, period int, prev *models.StockQuote) float64 <span class="cov0" title="0">{
        if period &lt;= 1 </span><span class="cov0" title="0">{
                return current
        }</span>
        <span class="cov0" title="0">emaPrev := current
        if prev == nil </span><span class="cov0" title="0">{
                return current
        }</span>
        <span class="cov0" title="0">switch period </span>{
        case emaPeriod20:<span class="cov0" title="0">
                emaPrev = prev.EMA20</span>
        case emaPeriod100:<span class="cov0" title="0">
                emaPrev = prev.EMA100</span>
        }

        <span class="cov0" title="0">alpha := 2.0 / float64(period-1)
        return alpha*current + (1-alpha)*emaPrev</span>
}

func getEnvString(key, fallback string) string <span class="cov0" title="0">{
        if v := strings.TrimSpace(os.Getenv(key)); v != "" </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov0" title="0">return fallback</span>
}

func getEnvInt(key string, fallback int) int <span class="cov0" title="0">{
        raw := strings.TrimSpace(os.Getenv(key))
        if raw == "" </span><span class="cov0" title="0">{
                return fallback
        }</span>
        <span class="cov0" title="0">n, err := strconv.Atoi(raw)
        if err != nil || n &lt;= 0 </span><span class="cov0" title="0">{
                return fallback
        }</span>
        <span class="cov0" title="0">return n</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package handler

import (
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "strings"

        "github.com/danielgtaylor/huma/v2"
        "github.com/golang-jwt/jwt/v5"

        "sun-stockanalysis-api/internal/authctx"
        "sun-stockanalysis-api/pkg/response"
        "sun-stockanalysis-api/pkg/status"
)

func authMiddleware(secret, issuer string) func(ctx huma.Context, next func(huma.Context)) <span class="cov0" title="0">{
        return func(ctx huma.Context, next func(huma.Context)) </span><span class="cov0" title="0">{
                if secret == "" </span><span class="cov0" title="0">{
                        writeAuthError(ctx, http.StatusUnauthorized, "auth secret not configured")
                        return
                }</span>

                <span class="cov0" title="0">authHeader := ctx.Header("Authorization")

                if authHeader == "" || !strings.HasPrefix(strings.ToLower(authHeader), "bearer ") </span><span class="cov0" title="0">{
                        writeAuthError(ctx, http.StatusUnauthorized, "missing or invalid authorization header")
                        return
                }</span>

                <span class="cov0" title="0">tokenString := strings.TrimSpace(authHeader[len("bearer "):])

                if tokenString == "" </span><span class="cov0" title="0">{
                        writeAuthError(ctx, http.StatusUnauthorized, "missing token")
                        return
                }</span>

                <span class="cov0" title="0">claims := &amp;jwt.RegisteredClaims{}

                options := []jwt.ParserOption{
                        jwt.WithValidMethods([]string{jwt.SigningMethodHS256.Name}),
                }
                if issuer != "" </span><span class="cov0" title="0">{
                        options = append(options, jwt.WithIssuer(issuer))
                }</span>

                <span class="cov0" title="0">token, err := jwt.ParseWithClaims(tokenString, claims, func(t *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected signing method")
                        }</span>
                        <span class="cov0" title="0">return []byte(secret), nil</span>
                }, options...)

                <span class="cov0" title="0">if err != nil || !token.Valid || claims.Subject == "" </span><span class="cov0" title="0">{
                        log.Printf(
                                "auth invalid token: err=%v valid=%v sub=%q iss=%q exp=%v iat=%v",
                                err,
                                token != nil &amp;&amp; token.Valid,
                                claims.Subject,
                                claims.Issuer,
                                claims.ExpiresAt,
                                claims.IssuedAt,
                        )
                        writeAuthError(ctx, http.StatusUnauthorized, "invalid token")
                        return
                }</span>

                <span class="cov0" title="0">next(huma.WithValue(ctx, authctx.UserIDContextKey(), claims.Subject))</span>
        }
}

func writeAuthError(ctx huma.Context, statusCode int, message string) <span class="cov0" title="0">{
        ctx.SetStatus(statusCode)
        ctx.SetHeader("Content-Type", "application/json; charset=utf-8")
        code, msg := statusForHTTP(statusCode)
        _ = json.NewEncoder(ctx.BodyWriter()).Encode(response.Error(code, msg, message))
}</span>

func statusForHTTP(httpStatus int) (string, string) <span class="cov0" title="0">{
        switch httpStatus </span>{
        case http.StatusBadRequest:<span class="cov0" title="0">
                return status.CodeInvalidParam, status.MsgInvalidParam</span>
        case http.StatusUnauthorized:<span class="cov0" title="0">
                return status.CodeUnauthorized, status.MsgUnauthorized</span>
        case http.StatusRequestTimeout:<span class="cov0" title="0">
                return status.CodeRequestTimeout, status.MsgRequestTimeout</span>
        case http.StatusInternalServerError:<span class="cov0" title="0">
                return status.CodeSystemError, status.MsgSystemError</span>
        default:<span class="cov0" title="0">
                return status.CodeGeneralError, status.MsgGeneralError</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package handler

import (
        "github.com/danielgtaylor/huma/v2"

        "sun-stockanalysis-api/internal/controllers"
        "sun-stockanalysis-api/internal/routes"
)

const apiBasePath = "/v1"

func RegisterRoutes(rootApi huma.API, controllers *controllers.Controllers, authSecret, authIssuer string) <span class="cov0" title="0">{
        // rootApi.UseMiddleware(requestIDMiddleware)

        routes.RegisterHealthRoutes(rootApi, controllers)
        v1Api := huma.NewGroup(rootApi, apiBasePath)

        routes.RegisterAuthRoutes(v1Api, controllers)
        routes.RegisterStockRoutes(v1Api, controllers, authMiddleware(authSecret, authIssuer))
        routes.RegisterStockQuoteRoutes(v1Api, controllers, authMiddleware(authSecret, authIssuer))
        routes.RegisterStockDailyRoutes(v1Api, controllers, authMiddleware(authSecret, authIssuer))
        routes.RegisterCompanyNewsRoutes(v1Api, controllers, authMiddleware(authSecret, authIssuer))
        routes.RegisterRelationNewsRoutes(v1Api, controllers, authMiddleware(authSecret, authIssuer))
        routes.RegisterPushSubscriptionRoutes(v1Api, controllers, authMiddleware(authSecret, authIssuer))
}</span>

// func requestIDMiddleware(ctx huma.Context, next func(huma.Context)) {
//         if ctx.Header("X-Request-Id") == "" {
//                 ctx.SetHeader("X-Request-Id", uuid.NewString())
//         }
//         next(ctx)
// }
</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by mockery v2.53.5. DO NOT EDIT.

package auth_mock

import (
        auth "sun-stockanalysis-api/internal/domains/auth"

        mock "github.com/stretchr/testify/mock"
)

// MockAuthService is an autogenerated mock type for the AuthService type
type MockAuthService struct {
        mock.Mock
}

type MockAuthService_Expecter struct {
        mock *mock.Mock
}

func (_m *MockAuthService) EXPECT() *MockAuthService_Expecter <span class="cov0" title="0">{
        return &amp;MockAuthService_Expecter{mock: &amp;_m.Mock}
}</span>

// Login provides a mock function with given fields: input
func (_m *MockAuthService) Login(input auth.LoginInput) (*auth.LoginResult, error) <span class="cov0" title="0">{
        ret := _m.Called(input)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Login")</span>
        }

        <span class="cov0" title="0">var r0 *auth.LoginResult
        var r1 error
        if rf, ok := ret.Get(0).(func(auth.LoginInput) (*auth.LoginResult, error)); ok </span><span class="cov0" title="0">{
                return rf(input)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(auth.LoginInput) *auth.LoginResult); ok </span><span class="cov0" title="0">{
                r0 = rf(input)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*auth.LoginResult)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(auth.LoginInput) error); ok </span><span class="cov0" title="0">{
                r1 = rf(input)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockAuthService_Login_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Login'
type MockAuthService_Login_Call struct {
        *mock.Call
}

// Login is a helper method to define mock.On call
//   - input auth.LoginInput
func (_e *MockAuthService_Expecter) Login(input interface{}) *MockAuthService_Login_Call <span class="cov0" title="0">{
        return &amp;MockAuthService_Login_Call{Call: _e.mock.On("Login", input)}
}</span>

func (_c *MockAuthService_Login_Call) Run(run func(input auth.LoginInput)) *MockAuthService_Login_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(auth.LoginInput))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockAuthService_Login_Call) Return(_a0 *auth.LoginResult, _a1 error) *MockAuthService_Login_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockAuthService_Login_Call) RunAndReturn(run func(auth.LoginInput) (*auth.LoginResult, error)) *MockAuthService_Login_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Refresh provides a mock function with given fields: input
func (_m *MockAuthService) Refresh(input auth.RefreshInput) (*auth.LoginResult, error) <span class="cov0" title="0">{
        ret := _m.Called(input)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Refresh")</span>
        }

        <span class="cov0" title="0">var r0 *auth.LoginResult
        var r1 error
        if rf, ok := ret.Get(0).(func(auth.RefreshInput) (*auth.LoginResult, error)); ok </span><span class="cov0" title="0">{
                return rf(input)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(auth.RefreshInput) *auth.LoginResult); ok </span><span class="cov0" title="0">{
                r0 = rf(input)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*auth.LoginResult)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(auth.RefreshInput) error); ok </span><span class="cov0" title="0">{
                r1 = rf(input)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockAuthService_Refresh_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Refresh'
type MockAuthService_Refresh_Call struct {
        *mock.Call
}

// Refresh is a helper method to define mock.On call
//   - input auth.RefreshInput
func (_e *MockAuthService_Expecter) Refresh(input interface{}) *MockAuthService_Refresh_Call <span class="cov0" title="0">{
        return &amp;MockAuthService_Refresh_Call{Call: _e.mock.On("Refresh", input)}
}</span>

func (_c *MockAuthService_Refresh_Call) Run(run func(input auth.RefreshInput)) *MockAuthService_Refresh_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(auth.RefreshInput))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockAuthService_Refresh_Call) Return(_a0 *auth.LoginResult, _a1 error) *MockAuthService_Refresh_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockAuthService_Refresh_Call) RunAndReturn(run func(auth.RefreshInput) (*auth.LoginResult, error)) *MockAuthService_Refresh_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Register provides a mock function with given fields: input
func (_m *MockAuthService) Register(input auth.RegisterInput) (*auth.RegisterResult, error) <span class="cov0" title="0">{
        ret := _m.Called(input)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Register")</span>
        }

        <span class="cov0" title="0">var r0 *auth.RegisterResult
        var r1 error
        if rf, ok := ret.Get(0).(func(auth.RegisterInput) (*auth.RegisterResult, error)); ok </span><span class="cov0" title="0">{
                return rf(input)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(auth.RegisterInput) *auth.RegisterResult); ok </span><span class="cov0" title="0">{
                r0 = rf(input)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*auth.RegisterResult)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(auth.RegisterInput) error); ok </span><span class="cov0" title="0">{
                r1 = rf(input)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockAuthService_Register_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Register'
type MockAuthService_Register_Call struct {
        *mock.Call
}

// Register is a helper method to define mock.On call
//   - input auth.RegisterInput
func (_e *MockAuthService_Expecter) Register(input interface{}) *MockAuthService_Register_Call <span class="cov0" title="0">{
        return &amp;MockAuthService_Register_Call{Call: _e.mock.On("Register", input)}
}</span>

func (_c *MockAuthService_Register_Call) Run(run func(input auth.RegisterInput)) *MockAuthService_Register_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(auth.RegisterInput))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockAuthService_Register_Call) Return(_a0 *auth.RegisterResult, _a1 error) *MockAuthService_Register_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockAuthService_Register_Call) RunAndReturn(run func(auth.RegisterInput) (*auth.RegisterResult, error)) *MockAuthService_Register_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockAuthService creates a new instance of MockAuthService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAuthService(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockAuthService <span class="cov0" title="0">{
        mock := &amp;MockAuthService{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by mockery v2.53.5. DO NOT EDIT.

package stock_mock

import (
        http "net/http"

        mock "github.com/stretchr/testify/mock"
)

// MockHTTPClient is an autogenerated mock type for the HTTPClient type
type MockHTTPClient struct {
        mock.Mock
}

type MockHTTPClient_Expecter struct {
        mock *mock.Mock
}

func (_m *MockHTTPClient) EXPECT() *MockHTTPClient_Expecter <span class="cov0" title="0">{
        return &amp;MockHTTPClient_Expecter{mock: &amp;_m.Mock}
}</span>

// Do provides a mock function with given fields: req
func (_m *MockHTTPClient) Do(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        ret := _m.Called(req)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Do")</span>
        }

        <span class="cov0" title="0">var r0 *http.Response
        var r1 error
        if rf, ok := ret.Get(0).(func(*http.Request) (*http.Response, error)); ok </span><span class="cov0" title="0">{
                return rf(req)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(*http.Request) *http.Response); ok </span><span class="cov0" title="0">{
                r0 = rf(req)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*http.Response)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(*http.Request) error); ok </span><span class="cov0" title="0">{
                r1 = rf(req)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockHTTPClient_Do_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Do'
type MockHTTPClient_Do_Call struct {
        *mock.Call
}

// Do is a helper method to define mock.On call
//   - req *http.Request
func (_e *MockHTTPClient_Expecter) Do(req interface{}) *MockHTTPClient_Do_Call <span class="cov0" title="0">{
        return &amp;MockHTTPClient_Do_Call{Call: _e.mock.On("Do", req)}
}</span>

func (_c *MockHTTPClient_Do_Call) Run(run func(req *http.Request)) *MockHTTPClient_Do_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(*http.Request))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockHTTPClient_Do_Call) Return(_a0 *http.Response, _a1 error) *MockHTTPClient_Do_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockHTTPClient_Do_Call) RunAndReturn(run func(*http.Request) (*http.Response, error)) *MockHTTPClient_Do_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockHTTPClient creates a new instance of MockHTTPClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockHTTPClient(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockHTTPClient <span class="cov0" title="0">{
        mock := &amp;MockHTTPClient{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Code generated by mockery v2.53.5. DO NOT EDIT.

package stock_mock

import (
        models "sun-stockanalysis-api/internal/models"

        mock "github.com/stretchr/testify/mock"

        stock "sun-stockanalysis-api/internal/domains/stock"

        uuid "github.com/google/uuid"
)

// MockStockService is an autogenerated mock type for the StockService type
type MockStockService struct {
        mock.Mock
}

type MockStockService_Expecter struct {
        mock *mock.Mock
}

func (_m *MockStockService) EXPECT() *MockStockService_Expecter <span class="cov0" title="0">{
        return &amp;MockStockService_Expecter{mock: &amp;_m.Mock}
}</span>

// CreateStock provides a mock function with given fields: input
func (_m *MockStockService) CreateStock(input stock.CreateStockInput) error <span class="cov0" title="0">{
        ret := _m.Called(input)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateStock")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(stock.CreateStockInput) error); ok </span><span class="cov0" title="0">{
                r0 = rf(input)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockStockService_CreateStock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateStock'
type MockStockService_CreateStock_Call struct {
        *mock.Call
}

// CreateStock is a helper method to define mock.On call
//   - input stock.CreateStockInput
func (_e *MockStockService_Expecter) CreateStock(input interface{}) *MockStockService_CreateStock_Call <span class="cov0" title="0">{
        return &amp;MockStockService_CreateStock_Call{Call: _e.mock.On("CreateStock", input)}
}</span>

func (_c *MockStockService_CreateStock_Call) Run(run func(input stock.CreateStockInput)) *MockStockService_CreateStock_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(stock.CreateStockInput))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockStockService_CreateStock_Call) Return(_a0 error) *MockStockService_CreateStock_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockStockService_CreateStock_Call) RunAndReturn(run func(stock.CreateStockInput) error) *MockStockService_CreateStock_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetStock provides a mock function with given fields: id
func (_m *MockStockService) GetStock(id uuid.UUID) (*models.Stock, error) <span class="cov0" title="0">{
        ret := _m.Called(id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetStock")</span>
        }

        <span class="cov0" title="0">var r0 *models.Stock
        var r1 error
        if rf, ok := ret.Get(0).(func(uuid.UUID) (*models.Stock, error)); ok </span><span class="cov0" title="0">{
                return rf(id)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(uuid.UUID) *models.Stock); ok </span><span class="cov0" title="0">{
                r0 = rf(id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.Stock)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockStockService_GetStock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetStock'
type MockStockService_GetStock_Call struct {
        *mock.Call
}

// GetStock is a helper method to define mock.On call
//   - id uuid.UUID
func (_e *MockStockService_Expecter) GetStock(id interface{}) *MockStockService_GetStock_Call <span class="cov0" title="0">{
        return &amp;MockStockService_GetStock_Call{Call: _e.mock.On("GetStock", id)}
}</span>

func (_c *MockStockService_GetStock_Call) Run(run func(id uuid.UUID)) *MockStockService_GetStock_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(uuid.UUID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockStockService_GetStock_Call) Return(_a0 *models.Stock, _a1 error) *MockStockService_GetStock_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockStockService_GetStock_Call) RunAndReturn(run func(uuid.UUID) (*models.Stock, error)) *MockStockService_GetStock_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockStockService creates a new instance of MockStockService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStockService(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockStockService <span class="cov0" title="0">{
        mock := &amp;MockStockService{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Code generated by mockery v2.53.5. DO NOT EDIT.

package repository_mock

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// MockHealthRepository is an autogenerated mock type for the HealthRepository type
type MockHealthRepository struct {
        mock.Mock
}

type MockHealthRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockHealthRepository) EXPECT() *MockHealthRepository_Expecter <span class="cov0" title="0">{
        return &amp;MockHealthRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// CheckDBStatus provides a mock function with given fields: ctx
func (_m *MockHealthRepository) CheckDBStatus(ctx context.Context) error <span class="cov0" title="0">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CheckDBStatus")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockHealthRepository_CheckDBStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckDBStatus'
type MockHealthRepository_CheckDBStatus_Call struct {
        *mock.Call
}

// CheckDBStatus is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockHealthRepository_Expecter) CheckDBStatus(ctx interface{}) *MockHealthRepository_CheckDBStatus_Call <span class="cov0" title="0">{
        return &amp;MockHealthRepository_CheckDBStatus_Call{Call: _e.mock.On("CheckDBStatus", ctx)}
}</span>

func (_c *MockHealthRepository_CheckDBStatus_Call) Run(run func(ctx context.Context)) *MockHealthRepository_CheckDBStatus_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockHealthRepository_CheckDBStatus_Call) Return(_a0 error) *MockHealthRepository_CheckDBStatus_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockHealthRepository_CheckDBStatus_Call) RunAndReturn(run func(context.Context) error) *MockHealthRepository_CheckDBStatus_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockHealthRepository creates a new instance of MockHealthRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockHealthRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockHealthRepository <span class="cov0" title="0">{
        mock := &amp;MockHealthRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Code generated by mockery v2.53.5. DO NOT EDIT.

package repository_mock

import (
        "time"

        models "sun-stockanalysis-api/internal/models"

        mock "github.com/stretchr/testify/mock"
)

// MockRefreshTokenRepository is an autogenerated mock type for the RefreshTokenRepository type
type MockRefreshTokenRepository struct {
        mock.Mock
}

type MockRefreshTokenRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockRefreshTokenRepository) EXPECT() *MockRefreshTokenRepository_Expecter <span class="cov0" title="0">{
        return &amp;MockRefreshTokenRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// Create provides a mock function with given fields: token
func (_m *MockRefreshTokenRepository) Create(token *models.RefreshTokens) error <span class="cov0" title="0">{
        ret := _m.Called(token)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Create")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(*models.RefreshTokens) error); ok </span><span class="cov0" title="0">{
                r0 = rf(token)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockRefreshTokenRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockRefreshTokenRepository_Create_Call struct {
        *mock.Call
}

// Create is a helper method to define mock.On call
//   - token *models.RefreshTokens
func (_e *MockRefreshTokenRepository_Expecter) Create(token interface{}) *MockRefreshTokenRepository_Create_Call <span class="cov0" title="0">{
        return &amp;MockRefreshTokenRepository_Create_Call{Call: _e.mock.On("Create", token)}
}</span>

func (_c *MockRefreshTokenRepository_Create_Call) Run(run func(token *models.RefreshTokens)) *MockRefreshTokenRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(*models.RefreshTokens))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockRefreshTokenRepository_Create_Call) Return(_a0 error) *MockRefreshTokenRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockRefreshTokenRepository_Create_Call) RunAndReturn(run func(*models.RefreshTokens) error) *MockRefreshTokenRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// FindByHash provides a mock function with given fields: hash
func (_m *MockRefreshTokenRepository) FindByHash(hash string) (*models.RefreshTokens, error) <span class="cov0" title="0">{
        ret := _m.Called(hash)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for FindByHash")</span>
        }

        <span class="cov0" title="0">var r0 *models.RefreshTokens
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (*models.RefreshTokens, error)); ok </span><span class="cov0" title="0">{
                return rf(hash)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) *models.RefreshTokens); ok </span><span class="cov0" title="0">{
                r0 = rf(hash)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.RefreshTokens)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(hash)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockRefreshTokenRepository_FindByHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByHash'
type MockRefreshTokenRepository_FindByHash_Call struct {
        *mock.Call
}

// FindByHash is a helper method to define mock.On call
//   - hash string
func (_e *MockRefreshTokenRepository_Expecter) FindByHash(hash interface{}) *MockRefreshTokenRepository_FindByHash_Call <span class="cov0" title="0">{
        return &amp;MockRefreshTokenRepository_FindByHash_Call{Call: _e.mock.On("FindByHash", hash)}
}</span>

func (_c *MockRefreshTokenRepository_FindByHash_Call) Run(run func(hash string)) *MockRefreshTokenRepository_FindByHash_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockRefreshTokenRepository_FindByHash_Call) Return(_a0 *models.RefreshTokens, _a1 error) *MockRefreshTokenRepository_FindByHash_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockRefreshTokenRepository_FindByHash_Call) RunAndReturn(run func(string) (*models.RefreshTokens, error)) *MockRefreshTokenRepository_FindByHash_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// DeleteBefore provides a mock function with given fields: t
func (_m *MockRefreshTokenRepository) DeleteBefore(t time.Time) error <span class="cov0" title="0">{
        ret := _m.Called(t)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteBefore")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(time.Time) error); ok </span><span class="cov0" title="0">{
                r0 = rf(t)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// RevokeByHash provides a mock function with given fields: hash, revokedAt
func (_m *MockRefreshTokenRepository) RevokeByHash(hash string, revokedAt float64) error <span class="cov0" title="0">{
        ret := _m.Called(hash, revokedAt)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for RevokeByHash")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string, float64) error); ok </span><span class="cov0" title="0">{
                r0 = rf(hash, revokedAt)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockRefreshTokenRepository_RevokeByHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevokeByHash'
type MockRefreshTokenRepository_RevokeByHash_Call struct {
        *mock.Call
}

// RevokeByHash is a helper method to define mock.On call
//   - hash string
//   - revokedAt float64
func (_e *MockRefreshTokenRepository_Expecter) RevokeByHash(hash interface{}, revokedAt interface{}) *MockRefreshTokenRepository_RevokeByHash_Call <span class="cov0" title="0">{
        return &amp;MockRefreshTokenRepository_RevokeByHash_Call{Call: _e.mock.On("RevokeByHash", hash, revokedAt)}
}</span>

func (_c *MockRefreshTokenRepository_RevokeByHash_Call) Run(run func(hash string, revokedAt float64)) *MockRefreshTokenRepository_RevokeByHash_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string), args[1].(float64))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockRefreshTokenRepository_RevokeByHash_Call) Return(_a0 error) *MockRefreshTokenRepository_RevokeByHash_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockRefreshTokenRepository_RevokeByHash_Call) RunAndReturn(run func(string, float64) error) *MockRefreshTokenRepository_RevokeByHash_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockRefreshTokenRepository creates a new instance of MockRefreshTokenRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRefreshTokenRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockRefreshTokenRepository <span class="cov0" title="0">{
        mock := &amp;MockRefreshTokenRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by mockery v2.53.5. DO NOT EDIT.

package repository_mock

import (
        models "sun-stockanalysis-api/internal/models"

        mock "github.com/stretchr/testify/mock"

        uuid "github.com/google/uuid"
)

// MockStockRepository is an autogenerated mock type for the StockRepository type
type MockStockRepository struct {
        mock.Mock
}

type MockStockRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockStockRepository) EXPECT() *MockStockRepository_Expecter <span class="cov0" title="0">{
        return &amp;MockStockRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// Create provides a mock function with given fields: stock
func (_m *MockStockRepository) Create(stock *models.Stock) error <span class="cov0" title="0">{
        ret := _m.Called(stock)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Create")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(*models.Stock) error); ok </span><span class="cov0" title="0">{
                r0 = rf(stock)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockStockRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockStockRepository_Create_Call struct {
        *mock.Call
}

// Create is a helper method to define mock.On call
//   - stock *models.Stock
func (_e *MockStockRepository_Expecter) Create(stock interface{}) *MockStockRepository_Create_Call <span class="cov0" title="0">{
        return &amp;MockStockRepository_Create_Call{Call: _e.mock.On("Create", stock)}
}</span>

func (_c *MockStockRepository_Create_Call) Run(run func(stock *models.Stock)) *MockStockRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(*models.Stock))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockStockRepository_Create_Call) Return(_a0 error) *MockStockRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockStockRepository_Create_Call) RunAndReturn(run func(*models.Stock) error) *MockStockRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// EnsureMasterAssetType provides a mock function with given fields: name
func (_m *MockStockRepository) EnsureMasterAssetType(name string) error <span class="cov0" title="0">{
        ret := _m.Called(name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for EnsureMasterAssetType")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(name)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockStockRepository_EnsureMasterAssetType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnsureMasterAssetType'
type MockStockRepository_EnsureMasterAssetType_Call struct {
        *mock.Call
}

// EnsureMasterAssetType is a helper method to define mock.On call
//   - name string
func (_e *MockStockRepository_Expecter) EnsureMasterAssetType(name interface{}) *MockStockRepository_EnsureMasterAssetType_Call <span class="cov0" title="0">{
        return &amp;MockStockRepository_EnsureMasterAssetType_Call{Call: _e.mock.On("EnsureMasterAssetType", name)}
}</span>

func (_c *MockStockRepository_EnsureMasterAssetType_Call) Run(run func(name string)) *MockStockRepository_EnsureMasterAssetType_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockStockRepository_EnsureMasterAssetType_Call) Return(_a0 error) *MockStockRepository_EnsureMasterAssetType_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockStockRepository_EnsureMasterAssetType_Call) RunAndReturn(run func(string) error) *MockStockRepository_EnsureMasterAssetType_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// EnsureMasterExchange provides a mock function with given fields: name
func (_m *MockStockRepository) EnsureMasterExchange(name string) error <span class="cov0" title="0">{
        ret := _m.Called(name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for EnsureMasterExchange")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(name)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockStockRepository_EnsureMasterExchange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnsureMasterExchange'
type MockStockRepository_EnsureMasterExchange_Call struct {
        *mock.Call
}

// EnsureMasterExchange is a helper method to define mock.On call
//   - name string
func (_e *MockStockRepository_Expecter) EnsureMasterExchange(name interface{}) *MockStockRepository_EnsureMasterExchange_Call <span class="cov0" title="0">{
        return &amp;MockStockRepository_EnsureMasterExchange_Call{Call: _e.mock.On("EnsureMasterExchange", name)}
}</span>

func (_c *MockStockRepository_EnsureMasterExchange_Call) Run(run func(name string)) *MockStockRepository_EnsureMasterExchange_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockStockRepository_EnsureMasterExchange_Call) Return(_a0 error) *MockStockRepository_EnsureMasterExchange_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockStockRepository_EnsureMasterExchange_Call) RunAndReturn(run func(string) error) *MockStockRepository_EnsureMasterExchange_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// EnsureMasterSector provides a mock function with given fields: name
func (_m *MockStockRepository) EnsureMasterSector(name string) error <span class="cov0" title="0">{
        ret := _m.Called(name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for EnsureMasterSector")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(name)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockStockRepository_EnsureMasterSector_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnsureMasterSector'
type MockStockRepository_EnsureMasterSector_Call struct {
        *mock.Call
}

// EnsureMasterSector is a helper method to define mock.On call
//   - name string
func (_e *MockStockRepository_Expecter) EnsureMasterSector(name interface{}) *MockStockRepository_EnsureMasterSector_Call <span class="cov0" title="0">{
        return &amp;MockStockRepository_EnsureMasterSector_Call{Call: _e.mock.On("EnsureMasterSector", name)}
}</span>

func (_c *MockStockRepository_EnsureMasterSector_Call) Run(run func(name string)) *MockStockRepository_EnsureMasterSector_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockStockRepository_EnsureMasterSector_Call) Return(_a0 error) *MockStockRepository_EnsureMasterSector_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockStockRepository_EnsureMasterSector_Call) RunAndReturn(run func(string) error) *MockStockRepository_EnsureMasterSector_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// FindByID provides a mock function with given fields: id
func (_m *MockStockRepository) FindByID(id uuid.UUID) (*models.Stock, error) <span class="cov0" title="0">{
        ret := _m.Called(id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for FindByID")</span>
        }

        <span class="cov0" title="0">var r0 *models.Stock
        var r1 error
        if rf, ok := ret.Get(0).(func(uuid.UUID) (*models.Stock, error)); ok </span><span class="cov0" title="0">{
                return rf(id)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(uuid.UUID) *models.Stock); ok </span><span class="cov0" title="0">{
                r0 = rf(id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.Stock)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockStockRepository_FindByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByID'
type MockStockRepository_FindByID_Call struct {
        *mock.Call
}

// FindByID is a helper method to define mock.On call
//   - id uuid.UUID
func (_e *MockStockRepository_Expecter) FindByID(id interface{}) *MockStockRepository_FindByID_Call <span class="cov0" title="0">{
        return &amp;MockStockRepository_FindByID_Call{Call: _e.mock.On("FindByID", id)}
}</span>

func (_c *MockStockRepository_FindByID_Call) Run(run func(id uuid.UUID)) *MockStockRepository_FindByID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(uuid.UUID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockStockRepository_FindByID_Call) Return(_a0 *models.Stock, _a1 error) *MockStockRepository_FindByID_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockStockRepository_FindByID_Call) RunAndReturn(run func(uuid.UUID) (*models.Stock, error)) *MockStockRepository_FindByID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockStockRepository creates a new instance of MockStockRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStockRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockStockRepository <span class="cov0" title="0">{
        mock := &amp;MockStockRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Code generated by mockery v2.53.5. DO NOT EDIT.

package repository_mock

import (
        models "sun-stockanalysis-api/internal/models"

        mock "github.com/stretchr/testify/mock"

        time "time"

        uuid "github.com/google/uuid"
)

// MockUserRepository is an autogenerated mock type for the UserRepository type
type MockUserRepository struct {
        mock.Mock
}

type MockUserRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockUserRepository) EXPECT() *MockUserRepository_Expecter <span class="cov0" title="0">{
        return &amp;MockUserRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// Create provides a mock function with given fields: user
func (_m *MockUserRepository) Create(user *models.User) error <span class="cov0" title="0">{
        ret := _m.Called(user)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Create")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(*models.User) error); ok </span><span class="cov0" title="0">{
                r0 = rf(user)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockUserRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockUserRepository_Create_Call struct {
        *mock.Call
}

// Create is a helper method to define mock.On call
//   - user *models.User
func (_e *MockUserRepository_Expecter) Create(user interface{}) *MockUserRepository_Create_Call <span class="cov0" title="0">{
        return &amp;MockUserRepository_Create_Call{Call: _e.mock.On("Create", user)}
}</span>

func (_c *MockUserRepository_Create_Call) Run(run func(user *models.User)) *MockUserRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(*models.User))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUserRepository_Create_Call) Return(_a0 error) *MockUserRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockUserRepository_Create_Call) RunAndReturn(run func(*models.User) error) *MockUserRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// ExistsByEmail provides a mock function with given fields: email
func (_m *MockUserRepository) ExistsByEmail(email string) (bool, error) <span class="cov0" title="0">{
        ret := _m.Called(email)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ExistsByEmail")</span>
        }

        <span class="cov0" title="0">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (bool, error)); ok </span><span class="cov0" title="0">{
                return rf(email)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(email)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(email)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockUserRepository_ExistsByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExistsByEmail'
type MockUserRepository_ExistsByEmail_Call struct {
        *mock.Call
}

// ExistsByEmail is a helper method to define mock.On call
//   - email string
func (_e *MockUserRepository_Expecter) ExistsByEmail(email interface{}) *MockUserRepository_ExistsByEmail_Call <span class="cov0" title="0">{
        return &amp;MockUserRepository_ExistsByEmail_Call{Call: _e.mock.On("ExistsByEmail", email)}
}</span>

func (_c *MockUserRepository_ExistsByEmail_Call) Run(run func(email string)) *MockUserRepository_ExistsByEmail_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUserRepository_ExistsByEmail_Call) Return(_a0 bool, _a1 error) *MockUserRepository_ExistsByEmail_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockUserRepository_ExistsByEmail_Call) RunAndReturn(run func(string) (bool, error)) *MockUserRepository_ExistsByEmail_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// FindByEmail provides a mock function with given fields: email
func (_m *MockUserRepository) FindByEmail(email string) (*models.User, error) <span class="cov0" title="0">{
        ret := _m.Called(email)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for FindByEmail")</span>
        }

        <span class="cov0" title="0">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(email)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(email)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(email)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockUserRepository_FindByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByEmail'
type MockUserRepository_FindByEmail_Call struct {
        *mock.Call
}

// FindByEmail is a helper method to define mock.On call
//   - email string
func (_e *MockUserRepository_Expecter) FindByEmail(email interface{}) *MockUserRepository_FindByEmail_Call <span class="cov0" title="0">{
        return &amp;MockUserRepository_FindByEmail_Call{Call: _e.mock.On("FindByEmail", email)}
}</span>

func (_c *MockUserRepository_FindByEmail_Call) Run(run func(email string)) *MockUserRepository_FindByEmail_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUserRepository_FindByEmail_Call) Return(_a0 *models.User, _a1 error) *MockUserRepository_FindByEmail_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockUserRepository_FindByEmail_Call) RunAndReturn(run func(string) (*models.User, error)) *MockUserRepository_FindByEmail_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// FindByID provides a mock function with given fields: id
func (_m *MockUserRepository) FindByID(id uuid.UUID) (*models.User, error) <span class="cov0" title="0">{
        ret := _m.Called(id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for FindByID")</span>
        }

        <span class="cov0" title="0">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(uuid.UUID) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(id)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(uuid.UUID) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockUserRepository_FindByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByID'
type MockUserRepository_FindByID_Call struct {
        *mock.Call
}

// FindByID is a helper method to define mock.On call
//   - id uuid.UUID
func (_e *MockUserRepository_Expecter) FindByID(id interface{}) *MockUserRepository_FindByID_Call <span class="cov0" title="0">{
        return &amp;MockUserRepository_FindByID_Call{Call: _e.mock.On("FindByID", id)}
}</span>

func (_c *MockUserRepository_FindByID_Call) Run(run func(id uuid.UUID)) *MockUserRepository_FindByID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(uuid.UUID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUserRepository_FindByID_Call) Return(_a0 *models.User, _a1 error) *MockUserRepository_FindByID_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockUserRepository_FindByID_Call) RunAndReturn(run func(uuid.UUID) (*models.User, error)) *MockUserRepository_FindByID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// UpdateLastLogin provides a mock function with given fields: id, when
func (_m *MockUserRepository) UpdateLastLogin(id uuid.UUID, when time.Time) error <span class="cov0" title="0">{
        ret := _m.Called(id, when)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateLastLogin")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(uuid.UUID, time.Time) error); ok </span><span class="cov0" title="0">{
                r0 = rf(id, when)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockUserRepository_UpdateLastLogin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateLastLogin'
type MockUserRepository_UpdateLastLogin_Call struct {
        *mock.Call
}

// UpdateLastLogin is a helper method to define mock.On call
//   - id uuid.UUID
//   - when time.Time
func (_e *MockUserRepository_Expecter) UpdateLastLogin(id interface{}, when interface{}) *MockUserRepository_UpdateLastLogin_Call <span class="cov0" title="0">{
        return &amp;MockUserRepository_UpdateLastLogin_Call{Call: _e.mock.On("UpdateLastLogin", id, when)}
}</span>

func (_c *MockUserRepository_UpdateLastLogin_Call) Run(run func(id uuid.UUID, when time.Time)) *MockUserRepository_UpdateLastLogin_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(uuid.UUID), args[1].(time.Time))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUserRepository_UpdateLastLogin_Call) Return(_a0 error) *MockUserRepository_UpdateLastLogin_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockUserRepository_UpdateLastLogin_Call) RunAndReturn(run func(uuid.UUID, time.Time) error) *MockUserRepository_UpdateLastLogin_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockUserRepository creates a new instance of MockUserRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUserRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockUserRepository <span class="cov0" title="0">{
        mock := &amp;MockUserRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package models

import "github.com/google/uuid"

type AlertEvent struct {
        ID           uuid.UUID `gorm:"type:uuid;default:gen_random_uuid();primaryKey" json:"id"`
        Symbol       string    `gorm:"type:varchar(64);not null;index" json:"symbol"`
        TrendEMA20   int       `gorm:"column:trend_ema_20;not null" json:"trend_ema_20"`
        TrendTanhEMA int       `gorm:"column:trend_tanh_ema;not null" json:"trend_tanh_ema"`
        ScoreEMA        float64   `gorm:"not null" json:"score_ema"`
        ScorePCrossEMA        float64   `gorm:"not null" json:"score_p_cross_ema"`
        CreatedAt    LocalTime `gorm:"autoCreateTime" json:"created_at"`
}

func (AlertEvent) TableName() string <span class="cov0" title="0">{
        return "alert_events"
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package models

import (
        "github.com/google/uuid"
)

type CompanyNews struct {
        ID        uuid.UUID `gorm:"type:uuid;default:gen_random_uuid();primaryKey" json:"id"`
        Symbol  string      `gorm:"not null;varchar(64);" json:"symbol"`
        Headline string `gorm:"type:varchar(200);" json:"headline"`
        Source  string      `gorm:"not null;varchar(200);" json:"source"`
        Summary  string      `gorm:"not null;dvarchar(500);" json:"summary"`
        Url  string      `gorm:"not null;varchar(200);" json:"url"`
        CreatedAt LocalTime `gorm:"autoCreateTime" json:"created_at"`
        UpdatedAt LocalTime `gorm:"autoUpdateTime" json:"updated_at"`
}

func (CompanyNews) TableName() string <span class="cov0" title="0">{
        return "company_news"
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package models

import (
        "database/sql/driver"
        "encoding/json"
        "errors"
        "fmt"
        "time"
)

const localTimeLayout = "2006-01-02 15:04:05"
const localDateLayout = "2006-01-02"

var localTimeLocation = time.FixedZone("Asia/Bangkok", 7*60*60)

type LocalTime time.Time

type LocalDate time.Time

func NewLocalTime(t time.Time) LocalTime <span class="cov0" title="0">{
        return LocalTime(t.In(localTimeLocation))
}</span>

func NewLocalDate(t time.Time) LocalDate <span class="cov0" title="0">{
        tt := t.In(localTimeLocation)
        date := time.Date(tt.Year(), tt.Month(), tt.Day(), 0, 0, 0, 0, localTimeLocation)
        return LocalDate(date)
}</span>

func (t LocalTime) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        tt := time.Time(t)
        if tt.IsZero() </span><span class="cov0" title="0">{
                return []byte(`""`), nil
        }</span>
        <span class="cov0" title="0">return json.Marshal(tt.In(localTimeLocation).Format(localTimeLayout))</span>
}

func (t LocalDate) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        tt := time.Time(t)
        if tt.IsZero() </span><span class="cov0" title="0">{
                return []byte(`""`), nil
        }</span>
        <span class="cov0" title="0">return json.Marshal(tt.In(localTimeLocation).Format(localDateLayout))</span>
}

func (t *LocalTime) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                return errors.New("LocalTime: nil receiver")
        }</span>
        <span class="cov0" title="0">var s string
        if err := json.Unmarshal(b, &amp;s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if s == "" </span><span class="cov0" title="0">{
                *t = LocalTime(time.Time{})
                return nil
        }</span>
        <span class="cov0" title="0">parsed, err := time.ParseInLocation(localTimeLayout, s, localTimeLocation)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*t = LocalTime(parsed)
        return nil</span>
}

func (t *LocalDate) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                return errors.New("LocalDate: nil receiver")
        }</span>
        <span class="cov0" title="0">var s string
        if err := json.Unmarshal(b, &amp;s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if s == "" </span><span class="cov0" title="0">{
                *t = LocalDate(time.Time{})
                return nil
        }</span>
        <span class="cov0" title="0">parsed, err := time.ParseInLocation(localDateLayout, s, localTimeLocation)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*t = LocalDate(parsed)
        return nil</span>
}

func (t LocalTime) Value() (driver.Value, error) <span class="cov0" title="0">{
        tt := time.Time(t)
        if tt.IsZero() </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return tt.In(localTimeLocation), nil</span>
}

func (t LocalDate) Value() (driver.Value, error) <span class="cov0" title="0">{
        tt := time.Time(t)
        if tt.IsZero() </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">date := time.Date(tt.Year(), tt.Month(), tt.Day(), 0, 0, 0, 0, localTimeLocation)
        return date, nil</span>
}

func (t *LocalTime) Scan(value interface{}) error <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                return errors.New("LocalTime: nil receiver")
        }</span>
        <span class="cov0" title="0">switch v := value.(type) </span>{
        case time.Time:<span class="cov0" title="0">
                *t = LocalTime(v.In(localTimeLocation))
                return nil</span>
        case []byte:<span class="cov0" title="0">
                return t.parseString(string(v))</span>
        case string:<span class="cov0" title="0">
                return t.parseString(v)</span>
        case nil:<span class="cov0" title="0">
                *t = LocalTime(time.Time{})
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("LocalTime: unsupported type %T", value)</span>
        }
}

func (t *LocalDate) Scan(value interface{}) error <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                return errors.New("LocalDate: nil receiver")
        }</span>
        <span class="cov0" title="0">switch v := value.(type) </span>{
        case time.Time:<span class="cov0" title="0">
                date := time.Date(v.Year(), v.Month(), v.Day(), 0, 0, 0, 0, localTimeLocation)
                *t = LocalDate(date)
                return nil</span>
        case []byte:<span class="cov0" title="0">
                return t.parseString(string(v))</span>
        case string:<span class="cov0" title="0">
                return t.parseString(v)</span>
        case nil:<span class="cov0" title="0">
                *t = LocalDate(time.Time{})
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("LocalDate: unsupported type %T", value)</span>
        }
}

func (t *LocalTime) parseString(s string) error <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                *t = LocalTime(time.Time{})
                return nil
        }</span>
        <span class="cov0" title="0">parsed, err := time.ParseInLocation(localTimeLayout, s, localTimeLocation)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*t = LocalTime(parsed)
        return nil</span>
}

func (t *LocalDate) parseString(s string) error <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                *t = LocalDate(time.Time{})
                return nil
        }</span>
        <span class="cov0" title="0">parsed, err := time.ParseInLocation(localDateLayout, s, localTimeLocation)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*t = LocalDate(parsed)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package models

import (
        "github.com/google/uuid"
)

type MarketOpen struct {
        ID           uuid.UUID `gorm:"type:uuid;default:gen_random_uuid();primaryKey" json:"id"`
        TradeDate    LocalDate `gorm:"type:date;not null;index:idx_market_date,unique" json:"trade_date"`
        IsTradingDay bool      `gorm:"not null;default:true" json:"is_trading_day"`
        OpenAt       LocalTime `gorm:"type:timestamptz" json:"open_at"`
        CloseAt      LocalTime `gorm:"type:timestamptz" json:"close_at"`
        CreatedAt    LocalTime `gorm:"autoCreateTime" json:"created_at"`
}

func (MarketOpen) TableName() string <span class="cov0" title="0">{
        return "market_open"
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package models

import "github.com/google/uuid"

type MasterAssetType struct {
        ID       uuid.UUID `gorm:"type:uuid;default:gen_random_uuid();primaryKey" json:"id"`
        Name     string    `gorm:"type:varchar(120);not null;unique" json:"name"`
        IsActive bool      `gorm:"not null;default:true" json:"is_active"`
}

func (MasterAssetType) TableName() string <span class="cov0" title="0">{
        return "master_asset_type"
}</span>

type MasterExchange struct {
        ID       uuid.UUID `gorm:"type:uuid;default:gen_random_uuid();primaryKey" json:"id"`
        Name     string    `gorm:"type:varchar(120);not null;unique" json:"name"`
        IsActive bool      `gorm:"not null;default:true" json:"is_active"`
}

func (MasterExchange) TableName() string <span class="cov0" title="0">{
        return "master_exchange"
}</span>

type MasterSector struct {
        ID       uuid.UUID `gorm:"type:uuid;default:gen_random_uuid();primaryKey" json:"id"`
        Name     string    `gorm:"type:varchar(120);not null;unique" json:"name"`
        IsActive bool      `gorm:"not null;default:true" json:"is_active"`
}

func (MasterSector) TableName() string <span class="cov0" title="0">{
        return "master_sector"
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package models

import (
        "time"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

type PushSubscription struct {
        ID        uuid.UUID `gorm:"type:uuid;default:gen_random_uuid();primaryKey" json:"id"`
        UserID    uuid.UUID `gorm:"type:uuid;not null;uniqueIndex:uidx_push_subscription_user_device,priority:1;index" json:"user_id"`
        DeviceID  string    `gorm:"type:varchar(128);not null;uniqueIndex:uidx_push_subscription_user_device,priority:2" json:"device_id"`
        Endpoint  string    `gorm:"type:text;not null;index" json:"endpoint"`
        P256DHKey string    `gorm:"column:p256dh_key;type:text;not null" json:"p256dh_key"`
        AuthKey   string    `gorm:"column:auth_key;type:text;not null" json:"auth_key"`
        UserAgent string    `gorm:"type:text" json:"user_agent"`
        IsActive  bool      `gorm:"not null;default:true;index" json:"is_active"`
        CreatedAt LocalTime `gorm:"autoCreateTime" json:"created_at"`
        UpdatedAt LocalTime `gorm:"autoUpdateTime" json:"updated_at"`
}

func (PushSubscription) TableName() string <span class="cov0" title="0">{
        return "push_subscriptions"
}</span>

func (s *PushSubscription) BeforeCreate(_ *gorm.DB) error <span class="cov0" title="0">{
        now := NewLocalTime(time.Now())
        if time.Time(s.CreatedAt).IsZero() </span><span class="cov0" title="0">{
                s.CreatedAt = now
        }</span>
        <span class="cov0" title="0">s.UpdatedAt = now
        return nil</span>
}

func (s *PushSubscription) BeforeUpdate(_ *gorm.DB) error <span class="cov0" title="0">{
        s.UpdatedAt = NewLocalTime(time.Now())
        return nil
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package models

import (
        "github.com/google/uuid"
)

type RelationNews struct {
        ID        uuid.UUID `gorm:"type:uuid;default:gen_random_uuid();primaryKey" json:"id"`
        Symbol    string    `gorm:"type:varchar(64);" json:"symbol"`
        RelationSymbol string `gorm:"type:varchar(64);" json:"relation_symbol"`
        IsActive  bool      `gorm:"not null;default:true;" json:"is_active"`
        CreatedAt LocalTime `gorm:"autoCreateTime" json:"created_at"`
        UpdatedAt LocalTime `gorm:"autoUpdateTime" json:"updated_at"`
}

func (RelationNews) TableName() string <span class="cov0" title="0">{
        return "relation_news"
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package models

import (
        "github.com/google/uuid"
)

type StockDaily struct {
        ID             uuid.UUID `gorm:"type:uuid;default:gen_random_uuid();primaryKey" json:"id"`
        Symbol         string    `gorm:"type:varchar(64);not null;index" json:"symbol"`
        PriceAverage   float64   `gorm:"not null" json:"price_average"`
        PriceHigh      float64   `gorm:"not null" json:"price_high"`
        PriceLow       float64   `gorm:"not null" json:"price_low"`
        PriceOpen      float64   `gorm:"not null" json:"price_open"`
        PricePrevClose float64   `gorm:"not null" json:"price_prev_close"`
        ChangePrice   *float64  `gorm:"" json:"change_price"`
        ChangePercent *float64  `gorm:"" json:"change_percent"`
        DeltaPrice     float64   `gorm:"column:dalta_price;not null" json:"dalta_price"`
        EMA20          float64   `gorm:"column:ema_20;not null" json:"ema_20"`
        EMA100         float64   `gorm:"column:ema_100;not null" json:"ema_100"`
        EMATrend       int       `gorm:"column:ema_trend;not null" json:"ema_trend"`
        TradeDate      LocalDate `gorm:"column:trend_date;not null" json:"trend_date"`
        CreatedAt      LocalTime `gorm:"autoCreateTime" json:"created_at"`
}

func (StockDaily) TableName() string <span class="cov0" title="0">{
        return "stock_daily"
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package models

import (
        "github.com/google/uuid"
)

type StockQuote struct {
        ID            uuid.UUID `gorm:"type:uuid;default:gen_random_uuid();primaryKey" json:"id"`
        Symbol        string    `gorm:"type:varchar(64);not null;index" json:"symbol"`
        PriceCurrent  float64   `gorm:"column:price_current;not null" json:"price_current"`
        ChangePrice   *float64  `gorm:"" json:"change_price"`
        ChangePercent *float64  `gorm:"" json:"change_percent"`
        EMA20         float64   `gorm:"column:ema_20;not null" json:"ema_20"`
        EMA100        float64   `gorm:"column:ema_100;not null" json:"ema_100"`
        TanhEMA       float64   `gorm:"column:tanh_ema;not null" json:"tanh_ema"`
        ChangeEMA20   float64   `gorm:"column:change_ema_20;not null" json:"change_ema_20"`
        ChangeTanhEMA float64   `gorm:"column:change_tanh_ema;not null" json:"change_tanh_ema"`
        EMATrend      int       `gorm:"column:ema_trend;not null" json:"ema_trend"`
        CreatedAt     LocalTime `gorm:"autoCreateTime" json:"created_at"`
}

func (StockQuote) TableName() string <span class="cov0" title="0">{
        return "stock_quotes"
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package realtime

import (
        "sync"

        "github.com/gofiber/websocket/v2"

        "sun-stockanalysis-api/internal/models"
)

type AlertEventNotifier interface {
        Notify(event *models.AlertEvent, message string)
}

type AlertHub struct {
        mu    sync.Mutex
        conns map[*websocket.Conn]struct{}
}

func NewAlertHub() *AlertHub <span class="cov0" title="0">{
        return &amp;AlertHub{
                conns: make(map[*websocket.Conn]struct{}),
        }
}</span>

func (h *AlertHub) Register(conn *websocket.Conn) <span class="cov0" title="0">{
        if h == nil || conn == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">h.mu.Lock()
        h.conns[conn] = struct{}{}
        h.mu.Unlock()</span>
}

func (h *AlertHub) Unregister(conn *websocket.Conn) <span class="cov0" title="0">{
        if h == nil || conn == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">h.mu.Lock()
        delete(h.conns, conn)
        h.mu.Unlock()</span>
}

func (h *AlertHub) Notify(event *models.AlertEvent, message string) <span class="cov0" title="0">{
        if h == nil || event == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">h.mu.Lock()
        defer h.mu.Unlock()

        payload := struct {
                Event   *models.AlertEvent `json:"event"`
                Message string            `json:"message"`
        }{
                Event:   event,
                Message: message,
        }

        for conn := range h.conns </span><span class="cov0" title="0">{
                if err := conn.WriteJSON(payload); err != nil </span><span class="cov0" title="0">{
                        _ = conn.Close()
                        delete(h.conns, conn)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package realtime

import "sun-stockanalysis-api/internal/models"

type CompositeAlertNotifier struct {
        notifiers []AlertEventNotifier
}

func NewCompositeAlertNotifier(notifiers ...AlertEventNotifier) *CompositeAlertNotifier <span class="cov0" title="0">{
        filtered := make([]AlertEventNotifier, 0, len(notifiers))
        for _, notifier := range notifiers </span><span class="cov0" title="0">{
                if notifier != nil </span><span class="cov0" title="0">{
                        filtered = append(filtered, notifier)
                }</span>
        }
        <span class="cov0" title="0">return &amp;CompositeAlertNotifier{notifiers: filtered}</span>
}

func (n *CompositeAlertNotifier) Notify(event *models.AlertEvent, message string) <span class="cov0" title="0">{
        if n == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for _, notifier := range n.notifiers </span><span class="cov0" title="0">{
                notifier.Notify(event, message)
        }</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package realtime

import (
        "sync"

        "github.com/gofiber/websocket/v2"

        "sun-stockanalysis-api/internal/models"
)

type StockQuoteNotifier interface {
        NotifyQuote(quote *models.StockQuote)
}

type StockQuoteHub struct {
        mu    sync.Mutex
        conns map[*websocket.Conn]struct{}
}

func NewStockQuoteHub() *StockQuoteHub <span class="cov0" title="0">{
        return &amp;StockQuoteHub{
                conns: make(map[*websocket.Conn]struct{}),
        }
}</span>

func (h *StockQuoteHub) Register(conn *websocket.Conn) <span class="cov0" title="0">{
        if h == nil || conn == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">h.mu.Lock()
        h.conns[conn] = struct{}{}
        h.mu.Unlock()</span>
}

func (h *StockQuoteHub) Unregister(conn *websocket.Conn) <span class="cov0" title="0">{
        if h == nil || conn == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">h.mu.Lock()
        delete(h.conns, conn)
        h.mu.Unlock()</span>
}

func (h *StockQuoteHub) NotifyQuote(quote *models.StockQuote) <span class="cov0" title="0">{
        if h == nil || quote == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">h.mu.Lock()
        defer h.mu.Unlock()

        payload := struct {
                Quote *models.StockQuote `json:"quote"`
        }{
                Quote: quote,
        }

        for conn := range h.conns </span><span class="cov0" title="0">{
                if err := conn.WriteJSON(payload); err != nil </span><span class="cov0" title="0">{
                        _ = conn.Close()
                        delete(h.conns, conn)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package repository

import (
        "errors"
        "time"

        "gorm.io/gorm"

        "sun-stockanalysis-api/internal/models"
)

type AlertEventRepository interface {
        Create(event *models.AlertEvent) error
        DeleteBefore(t time.Time) error
}

type AlertEventRepositoryImpl struct {
        db *gorm.DB
}

func NewAlertEventRepository(db *gorm.DB) AlertEventRepository <span class="cov0" title="0">{
        return &amp;AlertEventRepositoryImpl{db: db}
}</span>

func (r *AlertEventRepositoryImpl) Create(event *models.AlertEvent) error <span class="cov0" title="0">{
        if event == nil </span><span class="cov0" title="0">{
                return errors.New("alert event is nil")
        }</span>
        <span class="cov0" title="0">return r.db.Create(event).Error</span>
}

func (r *AlertEventRepositoryImpl) DeleteBefore(t time.Time) error <span class="cov0" title="0">{
        return r.db.
                Where("created_at &lt; ?", t).
                Delete(&amp;models.AlertEvent{}).Error
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package repository

import (
        "errors"
        "time"

        "gorm.io/gorm"

        "sun-stockanalysis-api/internal/models"
)

type CompanyNewsRepository interface {
        CreateMany(items []models.CompanyNews) error
        FindBySymbolsAndDate(symbols []string, start, end time.Time) ([]models.CompanyNews, error)
        DeleteBefore(t time.Time) error
}

type CompanyNewsRepositoryImpl struct {
        db *gorm.DB
}

func NewCompanyNewsRepository(db *gorm.DB) CompanyNewsRepository <span class="cov0" title="0">{
        return &amp;CompanyNewsRepositoryImpl{db: db}
}</span>

func (r *CompanyNewsRepositoryImpl) CreateMany(items []models.CompanyNews) error <span class="cov0" title="0">{
        if len(items) == 0 </span><span class="cov0" title="0">{
                return errors.New("company_news items are empty")
        }</span>
        <span class="cov0" title="0">return r.db.Create(&amp;items).Error</span>
}

func (r *CompanyNewsRepositoryImpl) FindBySymbolsAndDate(symbols []string, start, end time.Time) ([]models.CompanyNews, error) <span class="cov0" title="0">{
        if len(symbols) == 0 </span><span class="cov0" title="0">{
                return []models.CompanyNews{}, nil
        }</span>
        <span class="cov0" title="0">var items []models.CompanyNews
        if err := r.db.
                Where("symbol IN ? AND created_at &gt;= ? AND created_at &lt;= ?", symbols, start, end).
                Order("created_at desc").
                Find(&amp;items).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

func (r *CompanyNewsRepositoryImpl) DeleteBefore(t time.Time) error <span class="cov0" title="0">{
        if t.IsZero() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return r.db.
                Where("created_at &lt; ?", t).
                Delete(&amp;models.CompanyNews{}).Error</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package repository

import (
        "context"

        "sun-stockanalysis-api/internal/database"
        "gorm.io/gorm"
)

type HealthRepository interface {
        CheckDBStatus(ctx context.Context) error
}

type HealthRepositoryImpl struct {
        DB *gorm.DB
}

func (hr HealthRepositoryImpl) CheckDBStatus(ctx context.Context) error <span class="cov0" title="0">{

        return database.CheckPostgresHealth(hr.DB, ctx)
}</span>

func NewHealthRepository(DB *gorm.DB) HealthRepository <span class="cov0" title="0">{
        return HealthRepositoryImpl{
                DB: DB,
        }
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package repository

import (
        "errors"
        "time"

        "github.com/google/uuid"
        "gorm.io/gorm"

        "sun-stockanalysis-api/internal/models"
)

type MarketOpenRepository interface {
        FindByTradeDate(tradeDate time.Time) (*models.MarketOpen, error)
        Create(record *models.MarketOpen) error
        UpdateCloseAt(id uuid.UUID, closeAt time.Time, isTradingDay bool) error
        DeleteBefore(t time.Time) error
}

type MarketOpenRepositoryImpl struct {
        db *gorm.DB
}

func NewMarketOpenRepository(db *gorm.DB) MarketOpenRepository <span class="cov0" title="0">{
        return &amp;MarketOpenRepositoryImpl{db: db}
}</span>

func (r *MarketOpenRepositoryImpl) FindByTradeDate(tradeDate time.Time) (*models.MarketOpen, error) <span class="cov0" title="0">{
        var record models.MarketOpen
        if err := r.db.Where("trade_date = ?", tradeDate).First(&amp;record).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;record, nil</span>
}

func (r *MarketOpenRepositoryImpl) Create(record *models.MarketOpen) error <span class="cov0" title="0">{
        if record == nil </span><span class="cov0" title="0">{
                return errors.New("market_open record is nil")
        }</span>
        <span class="cov0" title="0">return r.db.Create(record).Error</span>
}

func (r *MarketOpenRepositoryImpl) UpdateCloseAt(id uuid.UUID, closeAt time.Time, isTradingDay bool) error <span class="cov0" title="0">{
        return r.db.Model(&amp;models.MarketOpen{}).
                Where("id = ?", id).
                Updates(map[string]any{
                        "close_at":       closeAt,
                        "is_trading_day": isTradingDay,
                }).Error
}</span>

func (r *MarketOpenRepositoryImpl) DeleteBefore(t time.Time) error <span class="cov0" title="0">{
        return r.db.
                Where("created_at &lt; ?", t).
                Delete(&amp;models.MarketOpen{}).Error
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package repository

import (
        "errors"
        "time"

        "github.com/google/uuid"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"

        "sun-stockanalysis-api/internal/models"
)

type PushSubscriptionRepository interface {
        Upsert(subscription *models.PushSubscription) error
        ListActive() ([]models.PushSubscription, error)
        DeleteByEndpoint(endpoint string) error
        DeleteByUserAndDevice(userID uuid.UUID, deviceID string) error
        DeleteBefore(t time.Time) error
}

type PushSubscriptionRepositoryImpl struct {
        db *gorm.DB
}

func NewPushSubscriptionRepository(db *gorm.DB) PushSubscriptionRepository <span class="cov0" title="0">{
        return &amp;PushSubscriptionRepositoryImpl{db: db}
}</span>

func (r *PushSubscriptionRepositoryImpl) Upsert(subscription *models.PushSubscription) error <span class="cov0" title="0">{
        if subscription == nil </span><span class="cov0" title="0">{
                return errors.New("push subscription is nil")
        }</span>

        <span class="cov0" title="0">return r.db.Clauses(clause.OnConflict{
                Columns: []clause.Column{
                        {Name: "user_id"},
                        {Name: "device_id"},
                },
                DoUpdates: clause.Assignments(map[string]any{
                        "endpoint":   subscription.Endpoint,
                        "p256dh_key": subscription.P256DHKey,
                        "auth_key":   subscription.AuthKey,
                        "user_agent": subscription.UserAgent,
                        "is_active":  true,
                }),
        }).Create(subscription).Error</span>
}

func (r *PushSubscriptionRepositoryImpl) ListActive() ([]models.PushSubscription, error) <span class="cov0" title="0">{
        var subscriptions []models.PushSubscription
        if err := r.db.
                Where("is_active = ?", true).
                Find(&amp;subscriptions).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return subscriptions, nil</span>
}

func (r *PushSubscriptionRepositoryImpl) DeleteByEndpoint(endpoint string) error <span class="cov0" title="0">{
        if endpoint == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return r.db.
                Where("endpoint = ?", endpoint).
                Delete(&amp;models.PushSubscription{}).Error</span>
}

func (r *PushSubscriptionRepositoryImpl) DeleteByUserAndDevice(userID uuid.UUID, deviceID string) error <span class="cov0" title="0">{
        if userID == uuid.Nil || deviceID == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return r.db.
                Where("user_id = ? AND device_id = ?", userID, deviceID).
                Delete(&amp;models.PushSubscription{}).Error</span>
}

func (r *PushSubscriptionRepositoryImpl) DeleteBefore(t time.Time) error <span class="cov0" title="0">{
        return r.db.
                Where("created_at &lt; ?", t).
                Delete(&amp;models.PushSubscription{}).Error
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package repository

import (
        "time"

        "gorm.io/gorm"

        "sun-stockanalysis-api/internal/models"
)

type RefreshTokenRepository interface {
        Create(token *models.RefreshTokens) error
        FindByHash(hash string) (*models.RefreshTokens, error)
        RevokeByHash(hash string, revokedAt float64) error
        DeleteBefore(t time.Time) error
}

type RefreshTokenRepositoryImpl struct {
        db *gorm.DB
}

func NewRefreshTokenRepository(db *gorm.DB) RefreshTokenRepository <span class="cov0" title="0">{
        return &amp;RefreshTokenRepositoryImpl{db: db}
}</span>

func (r *RefreshTokenRepositoryImpl) Create(token *models.RefreshTokens) error <span class="cov0" title="0">{
        return r.db.Create(token).Error
}</span>

func (r *RefreshTokenRepositoryImpl) FindByHash(hash string) (*models.RefreshTokens, error) <span class="cov0" title="0">{
        var t models.RefreshTokens
        if err := r.db.First(&amp;t, "token_hash = ?", hash).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;t, nil</span>
}

func (r *RefreshTokenRepositoryImpl) RevokeByHash(hash string, revokedAt float64) error <span class="cov0" title="0">{
        return r.db.Model(&amp;models.RefreshTokens{}).
                Where("token_hash = ?", hash).
                Update("revoked_at", revokedAt).Error
}</span>

func (r *RefreshTokenRepositoryImpl) DeleteBefore(t time.Time) error <span class="cov0" title="0">{
        return r.db.
                Where("created_at &lt; ?", t).
                Delete(&amp;models.RefreshTokens{}).Error
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package repository

import (
        "errors"

        "gorm.io/gorm"

        "sun-stockanalysis-api/internal/models"
)

type RelationNewsRepository interface {
        CreateMany(items []models.RelationNews) error
        ListDistinctRelationSymbols() ([]string, error)
        ListRelationSymbolsBySymbol(symbol string) ([]string, error)
}

type RelationNewsRepositoryImpl struct {
        db *gorm.DB
}

func NewRelationNewsRepository(db *gorm.DB) RelationNewsRepository <span class="cov0" title="0">{
        return &amp;RelationNewsRepositoryImpl{db: db}
}</span>

func (r *RelationNewsRepositoryImpl) CreateMany(items []models.RelationNews) error <span class="cov0" title="0">{
        if len(items) == 0 </span><span class="cov0" title="0">{
                return errors.New("relation_news items are empty")
        }</span>
        <span class="cov0" title="0">return r.db.Create(&amp;items).Error</span>
}

func (r *RelationNewsRepositoryImpl) ListDistinctRelationSymbols() ([]string, error) <span class="cov0" title="0">{
        var symbols []string
        if err := r.db.Model(&amp;models.RelationNews{}).
                Select("distinct relation_symbol").
                Where("relation_symbol &lt;&gt; ''").
                Pluck("relation_symbol", &amp;symbols).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return symbols, nil</span>
}

func (r *RelationNewsRepositoryImpl) ListRelationSymbolsBySymbol(symbol string) ([]string, error) <span class="cov0" title="0">{
        if symbol == "" </span><span class="cov0" title="0">{
                return nil, errors.New("symbol is empty")
        }</span>
        <span class="cov0" title="0">var symbols []string
        if err := r.db.Model(&amp;models.RelationNews{}).
                Select("distinct relation_symbol").
                Where("symbol = ? AND relation_symbol &lt;&gt; ''", symbol).
                Pluck("relation_symbol", &amp;symbols).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return symbols, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package repository

import (
        "github.com/google/uuid"
        "gorm.io/gorm"

        "sun-stockanalysis-api/internal/models"
)

type StockRepository interface {
        FindByID(id uuid.UUID) (*models.Stock, error)
        Create(stock *models.Stock) error
        ListSymbols() ([]string, error)
        FindAll() ([]models.Stock, error)
        EnsureMasterAssetType(name string) error
        EnsureMasterExchange(name string) error
        EnsureMasterSector(name string) error
}

type StockRepositoryImpl struct {
        db *gorm.DB // GORM DB instance
}

func NewStockRepository(db *gorm.DB) StockRepository <span class="cov0" title="0">{
        return &amp;StockRepositoryImpl{db: db}
}</span>

func (r *StockRepositoryImpl) FindByID(id uuid.UUID) (*models.Stock, error) <span class="cov0" title="0">{
        var s models.Stock
        if err := r.db.First(&amp;s, "id = ?", id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;s, nil</span>
}

func (r *StockRepositoryImpl) Create(s *models.Stock) error <span class="cov0" title="0">{
        return r.db.Create(s).Error
}</span>

func (r *StockRepositoryImpl) ListSymbols() ([]string, error) <span class="cov0" title="0">{
        var symbols []string
        if err := r.db.Model(&amp;models.Stock{}).
                Where("is_active = ?", true).
                Pluck("symbol", &amp;symbols).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return symbols, nil</span>
}

func (r *StockRepositoryImpl) FindAll() ([]models.Stock, error) <span class="cov0" title="0">{
        var stocks []models.Stock
        if err := r.db.
                Order("created_at desc").
                Find(&amp;stocks).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return stocks, nil</span>
}

func (r *StockRepositoryImpl) EnsureMasterAssetType(name string) error <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">record := models.MasterAssetType{Name: name, IsActive: true}
        return r.db.Where("name = ?", name).FirstOrCreate(&amp;record).Error</span>
}

func (r *StockRepositoryImpl) EnsureMasterExchange(name string) error <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">record := models.MasterExchange{Name: name, IsActive: true}
        return r.db.Where("name = ?", name).FirstOrCreate(&amp;record).Error</span>
}

func (r *StockRepositoryImpl) EnsureMasterSector(name string) error <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">record := models.MasterSector{Name: name, IsActive: true}
        return r.db.Where("name = ?", name).FirstOrCreate(&amp;record).Error</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package repository

import (
        "errors"

        "gorm.io/gorm"

        "sun-stockanalysis-api/internal/models"
)

type StockDailyRepository interface {
        Create(metric *models.StockDaily) error
        FindLatestBySymbol(symbol string) (*models.StockDaily, error)
        FindPreviousBySymbol(symbol string) ([]models.StockDaily, error)
        FindBySymbol(symbol string) ([]models.StockDaily, error)
}

type StockDailyRepositoryImpl struct {
        db *gorm.DB
}

func NewStockDailyRepository(db *gorm.DB) StockDailyRepository <span class="cov0" title="0">{
        return &amp;StockDailyRepositoryImpl{db: db}
}</span>

func (r *StockDailyRepositoryImpl) Create(metric *models.StockDaily) error <span class="cov0" title="0">{
        if metric == nil </span><span class="cov0" title="0">{
                return errors.New("stock daily is nil")
        }</span>
        <span class="cov0" title="0">return r.db.Create(metric).Error</span>
}

func (r *StockDailyRepositoryImpl) FindLatestBySymbol(symbol string) (*models.StockDaily, error) <span class="cov0" title="0">{
        if symbol == "" </span><span class="cov0" title="0">{
                return nil, errors.New("symbol is empty")
        }</span>
        <span class="cov0" title="0">var metric models.StockDaily
        if err := r.db.
                Where("symbol = ?", symbol).
                Order("created_at desc").
                First(&amp;metric).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;metric, nil</span>
}

func (r *StockDailyRepositoryImpl) FindBySymbol(symbol string) ([]models.StockDaily, error) <span class="cov0" title="0">{
        if symbol == "" </span><span class="cov0" title="0">{
                return nil, errors.New("symbol is empty")
        }</span>
        <span class="cov0" title="0">var metrics []models.StockDaily
        if err := r.db.
                Where("symbol = ?", symbol).
                Order("created_at desc").
                Find(&amp;metrics).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return metrics, nil</span>
}

func (r *StockDailyRepositoryImpl) FindPreviousBySymbol(symbol string) ([]models.StockDaily, error) <span class="cov0" title="0">{
        if symbol == "" </span><span class="cov0" title="0">{
                return nil, errors.New("symbol is empty")
        }</span>
        <span class="cov0" title="0">var metrics []models.StockDaily
        if err := r.db.
                Where("symbol = ?", symbol).
                Order("created_at desc").
                Offset(1).
                Limit(1).
                Find(&amp;metrics).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return metrics, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package repository

import (
        "errors"
        "time"

        "gorm.io/gorm"

        "sun-stockanalysis-api/internal/models"
)

type StockQuoteRepository interface {
        Create(quote *models.StockQuote) error
        FindLatestBySymbol(symbol string) (*models.StockQuote, error)
        FindLatestBySymbolBetween(symbol string, start, end time.Time, limit int) ([]models.StockQuote, error)
        FindBySymbolBetween(symbol string, start, end time.Time) ([]models.StockQuote, error)
        FindAll() ([]models.StockQuote, error)
        FindBySymbol(symbol string) ([]models.StockQuote, error)
        DeleteBefore(t time.Time) error
}

type StockQuoteRepositoryImpl struct {
        db *gorm.DB
}

func NewStockQuoteRepository(db *gorm.DB) StockQuoteRepository <span class="cov0" title="0">{
        return &amp;StockQuoteRepositoryImpl{db: db}
}</span>

func (r *StockQuoteRepositoryImpl) Create(quote *models.StockQuote) error <span class="cov0" title="0">{
        if quote == nil </span><span class="cov0" title="0">{
                return errors.New("stock quote is nil")
        }</span>
        <span class="cov0" title="0">return r.db.Create(quote).Error</span>
}

func (r *StockQuoteRepositoryImpl) FindLatestBySymbol(symbol string) (*models.StockQuote, error) <span class="cov0" title="0">{
        if symbol == "" </span><span class="cov0" title="0">{
                return nil, errors.New("symbol is empty")
        }</span>
        <span class="cov0" title="0">var quote models.StockQuote
        if err := r.db.
                Where("symbol = ?", symbol).
                Order("created_at desc").
                First(&amp;quote).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;quote, nil</span>
}

func (r *StockQuoteRepositoryImpl) FindLatestBySymbolBetween(symbol string, start, end time.Time, limit int) ([]models.StockQuote, error) <span class="cov0" title="0">{
        if symbol == "" </span><span class="cov0" title="0">{
                return nil, errors.New("symbol is empty")
        }</span>
        <span class="cov0" title="0">if limit &lt;= 0 </span><span class="cov0" title="0">{
                return []models.StockQuote{}, nil
        }</span>
        <span class="cov0" title="0">var quotes []models.StockQuote
        if err := r.db.
                Where("symbol = ? AND created_at &gt;= ? AND created_at &lt;= ?", symbol, start, end).
                Order("created_at desc").
                Limit(limit).
                Find(&amp;quotes).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return quotes, nil</span>
}

func (r *StockQuoteRepositoryImpl) FindBySymbolBetween(symbol string, start, end time.Time) ([]models.StockQuote, error) <span class="cov0" title="0">{
        if symbol == "" </span><span class="cov0" title="0">{
                return nil, errors.New("symbol is empty")
        }</span>
        <span class="cov0" title="0">var quotes []models.StockQuote
        if err := r.db.
                Where("symbol = ? AND created_at &gt;= ? AND created_at &lt;= ?", symbol, start, end).
                Order("created_at asc").
                Find(&amp;quotes).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return quotes, nil</span>
}

func (r *StockQuoteRepositoryImpl) FindAll() ([]models.StockQuote, error) <span class="cov0" title="0">{
        var quotes []models.StockQuote
        if err := r.db.
                Order("created_at desc").
                Find(&amp;quotes).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return quotes, nil</span>
}

func (r *StockQuoteRepositoryImpl) FindBySymbol(symbol string) ([]models.StockQuote, error) <span class="cov0" title="0">{
        if symbol == "" </span><span class="cov0" title="0">{
                return nil, errors.New("symbol is empty")
        }</span>
        <span class="cov0" title="0">var quotes []models.StockQuote
        if err := r.db.
                Where("symbol = ?", symbol).
                Order("created_at desc").
                Find(&amp;quotes).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return quotes, nil</span>
}

func (r *StockQuoteRepositoryImpl) DeleteBefore(t time.Time) error <span class="cov0" title="0">{
        if t.IsZero() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return r.db.
                Where("created_at &lt; ?", t).
                Delete(&amp;models.StockQuote{}).Error</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package repository

import (
        "time"

        "github.com/google/uuid"
        "gorm.io/gorm"

        "sun-stockanalysis-api/internal/models"
)

type UserRepository interface {
        FindByEmail(email string) (*models.User, error)
        ExistsByEmail(email string) (bool, error)
        Create(user *models.User) error
        FindByID(id uuid.UUID) (*models.User, error)
        UpdateLastLogin(id uuid.UUID, when time.Time) error
}

type UserRepositoryImpl struct {
        db *gorm.DB
}

func NewUserRepository(db *gorm.DB) UserRepository <span class="cov0" title="0">{
        return &amp;UserRepositoryImpl{db: db}
}</span>

func (r *UserRepositoryImpl) FindByEmail(email string) (*models.User, error) <span class="cov0" title="0">{
        var u models.User
        if err := r.db.First(&amp;u, "email = ? AND is_active = true", email).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;u, nil</span>
}

func (r *UserRepositoryImpl) FindByID(id uuid.UUID) (*models.User, error) <span class="cov0" title="0">{
        var u models.User
        if err := r.db.First(&amp;u, "id = ? AND is_active = true", id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;u, nil</span>
}

func (r *UserRepositoryImpl) ExistsByEmail(email string) (bool, error) <span class="cov0" title="0">{
        var count int64
        if err := r.db.Model(&amp;models.User{}).
                Where("email = ? AND is_active = true", email).
                Count(&amp;count).Error; err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

func (r *UserRepositoryImpl) Create(user *models.User) error <span class="cov0" title="0">{
        return r.db.Create(user).Error
}</span>

func (r *UserRepositoryImpl) UpdateLastLogin(id uuid.UUID, when time.Time) error <span class="cov0" title="0">{
        return r.db.Model(&amp;models.User{}).
                Where("id = ?", id).
                Update("last_login_at", when).Error
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package routes

import (
        "net/http"

        "github.com/danielgtaylor/huma/v2"

        "sun-stockanalysis-api/internal/controllers"
)

func RegisterAuthRoutes(api huma.API, controllers *controllers.Controllers) <span class="cov0" title="0">{
        huma.Register(api, huma.Operation{
                Method:  http.MethodPost,
                Path:    "/register",
                Summary: "Register",
                Tags:    v1Tags(),
        }, controllers.AuthController.Register)

        huma.Register(api, huma.Operation{
                Method:  http.MethodPost,
                Path:    "/login",
                Summary: "Login",
                Tags:    v1Tags(),
        }, controllers.AuthController.Login)

        huma.Register(api, huma.Operation{
                Method:  http.MethodPost,
                Path:    "/refresh",
                Summary: "Refresh access token",
                Tags:    v1Tags(),
        }, controllers.AuthController.Refresh)
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package routes

func v1Tags() []string <span class="cov0" title="0">{
        return []string{"v1"}
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package routes

import (
        "net/http"

        "github.com/danielgtaylor/huma/v2"

        "sun-stockanalysis-api/internal/controllers"
)

func RegisterCompanyNewsRoutes(api huma.API, controllers *controllers.Controllers, middleware func(huma.Context, func(huma.Context))) <span class="cov0" title="0">{
        protected := huma.NewGroup(api, "")
        protected.UseMiddleware(middleware)

        huma.Register(protected, huma.Operation{
                Method:  http.MethodGet,
                Path:    "/company-news",
                Summary: "List company news by relation symbols and date range",
                Tags:    v1Tags(),
        }, controllers.CompanyNewsController.ListBySymbolAndDate)
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package routes

import (
        "net/http"

        "github.com/danielgtaylor/huma/v2"

        "sun-stockanalysis-api/internal/controllers"
)

func RegisterHealthRoutes(api huma.API, controllers *controllers.Controllers) <span class="cov0" title="0">{
        tags := []string{"Health Check"}

        huma.Register(api, huma.Operation{
                Path:   "/healthz",
                Method: http.MethodGet,
                Tags:   tags,
        }, controllers.HealthController.Healthz)

        huma.Register(api, huma.Operation{
                Path:   "/readyz",
                Method: http.MethodGet,
                Tags:   tags,
        }, controllers.HealthController.Readyz)
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package routes

import (
        "net/http"

        "github.com/danielgtaylor/huma/v2"

        "sun-stockanalysis-api/internal/controllers"
)

func RegisterPushSubscriptionRoutes(api huma.API, controllers *controllers.Controllers, middleware func(huma.Context, func(huma.Context))) <span class="cov0" title="0">{
        protected := huma.NewGroup(api, "")
        protected.UseMiddleware(middleware)

        huma.Register(protected, huma.Operation{
                Method:  http.MethodGet,
                Path:    "/push/vapid-public-key",
                Summary: "Get VAPID public key",
                Tags:    v1Tags(),
        }, controllers.PushSubscriptionController.GetVAPIDPublicKey)

        huma.Register(protected, huma.Operation{
                Method:  http.MethodPost,
                Path:    "/push/subscriptions",
                Summary: "Create or update push subscription",
                Tags:    v1Tags(),
        }, controllers.PushSubscriptionController.Upsert)

        huma.Register(protected, huma.Operation{
                Method:  http.MethodDelete,
                Path:    "/push/subscriptions",
                Summary: "Delete push subscription by device_id",
                Tags:    v1Tags(),
        }, controllers.PushSubscriptionController.Delete)
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package routes

import (
        "net/http"

        "github.com/danielgtaylor/huma/v2"

        "sun-stockanalysis-api/internal/controllers"
)

func RegisterRelationNewsRoutes(api huma.API, controllers *controllers.Controllers, middleware func(huma.Context, func(huma.Context))) <span class="cov0" title="0">{
        protected := huma.NewGroup(api, "")
        protected.UseMiddleware(middleware)

        huma.Register(protected, huma.Operation{
                Method:        http.MethodPost,
                Path:          "/relation-news",
                Summary:       "Create relation news",
                Tags:          v1Tags(),
                DefaultStatus: http.StatusCreated,
        }, controllers.RelationNewsController.Create)
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package routes

import (
        "net/http"

        "github.com/danielgtaylor/huma/v2"

        "sun-stockanalysis-api/internal/controllers"
)

func RegisterStockRoutes(api huma.API, controllers *controllers.Controllers, middleware func(huma.Context, func(huma.Context))) <span class="cov0" title="0">{
        protected := huma.NewGroup(api, "")
        protected.UseMiddleware(middleware)

        huma.Register(protected, huma.Operation{
                Method:  http.MethodGet,
                Path:    "/stocks",
                Summary: "List all stocks",
                Tags:    v1Tags(),
        }, controllers.StockController.ListStocks)

        huma.Register(protected, huma.Operation{
                Method:  http.MethodGet,
                Path:    "/stocks/{id}",
                Summary: "Get stock by ID",
                Tags:    v1Tags(),
        }, controllers.StockController.GetStock)

        huma.Register(protected, huma.Operation{
                Method:        http.MethodPost,
                Path:          "/stocks",
                Summary:       "Create stock",
                Tags:          v1Tags(),
                DefaultStatus: http.StatusCreated,
        }, controllers.StockController.CreateStock)
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package routes

import (
        "net/http"

        "github.com/danielgtaylor/huma/v2"

        "sun-stockanalysis-api/internal/controllers"
)

func RegisterStockDailyRoutes(api huma.API, controllers *controllers.Controllers, middleware func(huma.Context, func(huma.Context))) <span class="cov0" title="0">{
        protected := huma.NewGroup(api, "")
        protected.UseMiddleware(middleware)

        huma.Register(protected, huma.Operation{
                Method:  http.MethodGet,
                Path:    "/stock-daily",
                Summary: "List stock daily by symbol",
                Tags:    v1Tags(),
        }, controllers.StockDailyController.ListBySymbol)
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package routes

import (
        "net/http"

        "github.com/danielgtaylor/huma/v2"

        "sun-stockanalysis-api/internal/controllers"
)

func RegisterStockQuoteRoutes(api huma.API, controllers *controllers.Controllers, middleware func(huma.Context, func(huma.Context))) <span class="cov0" title="0">{
        protected := huma.NewGroup(api, "")
        protected.UseMiddleware(middleware)

        huma.Register(protected, huma.Operation{
                Method:  http.MethodGet,
                Path:    "/stock-quotes",
                Summary: "List all stock quotes",
                Tags:    v1Tags(),
        }, controllers.StockQuoteController.ListAll)
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package server

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/danielgtaylor/huma/v2"
        "github.com/danielgtaylor/huma/v2/adapters/humafiber"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/cors"
        "github.com/gofiber/websocket/v2"

        "sun-stockanalysis-api/internal/configurations"
        "sun-stockanalysis-api/internal/controllers"
        "sun-stockanalysis-api/internal/handler"
        "sun-stockanalysis-api/internal/realtime"
        "sun-stockanalysis-api/pkg/apierror"
        "sun-stockanalysis-api/pkg/logger"
)

type Server struct {
        cfg *configurations.Config
        app *fiber.App
        log *logger.Logger
}

func NewServer(
        cfg *configurations.Config,
        controllers *controllers.Controllers,
        alertHub *realtime.AlertHub,
        stockQuoteHub *realtime.StockQuoteHub,
        log *logger.Logger,
) *Server <span class="cov0" title="0">{
        app := fiber.New(fiber.Config{
                AppName: "sun-stockanalysis-api",
                ErrorHandler: func(c *fiber.Ctx, err error) error </span><span class="cov0" title="0">{
                        status, resp := apierror.ToResponse(err)
                        return c.Status(status).JSON(resp)
                }</span>,
        })

        <span class="cov0" title="0">contextPath := normalizeContextPath(cfg.Server.ContextPath)
        app.Use(cors.New(cors.Config{
                AllowOrigins:     strings.Join(cfg.Server.AllowedOrigins, ","),
                AllowMethods:     "GET,POST,PUT,PATCH,DELETE,OPTIONS",
                AllowHeaders:     "Origin,Content-Type,Accept,Authorization,X-Correlation-Id",
                ExposeHeaders:    "X-Correlation-Id",
                AllowCredentials: true,
        }))
        apiGroup := app.Group(contextPath)

        apiGroup.Use(func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                if c.Method() == fiber.MethodOptions </span><span class="cov0" title="0">{
                        return c.SendStatus(fiber.StatusNoContent)
                }</span>

                <span class="cov0" title="0">path := c.Path()
                if path == contextPath+"/docs" ||
                        path == contextPath+"/openapi.json" ||
                        path == contextPath+"/openapi.yaml" ||
                        path == contextPath+"/schemas" ||
                        path == contextPath+"/alerts/ws" ||
                        path == contextPath+"/stock-quotes/ws" </span><span class="cov0" title="0">{
                        return c.Next()
                }</span>

                <span class="cov0" title="0">correlationID := c.Get("X-Correlation-Id")
                if correlationID == "" </span><span class="cov0" title="0">{
                        return fiber.NewError(fiber.StatusBadRequest, "X-Correlation-Id header is required")
                }</span>

                <span class="cov0" title="0">c.Set("X-Correlation-Id", correlationID)
                ctx := context.WithValue(c.UserContext(), logger.CorrelationIDKey, correlationID)
                c.SetUserContext(ctx)
                c.Context().SetUserValue(logger.CorrelationIDKey, correlationID)

                start := time.Now()
                err := c.Next()
                if log != nil </span><span class="cov0" title="0">{
                        log.With("correlation_id", correlationID).Infof(
                                "%s %s %d %s",
                                c.Method(),
                                c.OriginalURL(),
                                c.Response().StatusCode(),
                                time.Since(start),
                        )
                }</span>
                <span class="cov0" title="0">return err</span>
        })

        <span class="cov0" title="0">huma.NewError = apierror.NewHumaError
        huma.NewErrorWithContext = func(_ huma.Context, status int, msg string, errs ...error) huma.StatusError </span><span class="cov0" title="0">{
                return apierror.NewHumaError(status, msg, errs...)
        }</span>

        <span class="cov0" title="0">apiConfig := huma.DefaultConfig("sun-stockanalysis-api", "1.0.0")
        apiConfig.Servers = []*huma.Server{{URL: contextPath}}
        if apiConfig.Components.SecuritySchemes == nil </span><span class="cov0" title="0">{
                apiConfig.Components.SecuritySchemes = map[string]*huma.SecurityScheme{}
        }</span>
        <span class="cov0" title="0">apiConfig.Components.SecuritySchemes["CorrelationId"] = &amp;huma.SecurityScheme{
                Type: "apiKey",
                In:   "header",
                Name: "X-Correlation-Id",
        }
        apiConfig.Components.SecuritySchemes["BearerAuth"] = &amp;huma.SecurityScheme{
                Type:         "http",
                Scheme:       "bearer",
                BearerFormat: "JWT",
        }

        humaAPI := humafiber.NewWithGroup(app, apiGroup, apiConfig)
        handler.RegisterRoutes(humaAPI, controllers, cfg.State.Secret, cfg.State.Issuer)
        addCorrelationIDToOpenAPI(humaAPI)
        addBearerAuthToOpenAPI(humaAPI)

        if alertHub != nil </span><span class="cov0" title="0">{
                apiGroup.Get("/alerts/ws", websocket.New(func(c *websocket.Conn) </span><span class="cov0" title="0">{
                        alertHub.Register(c)
                        defer alertHub.Unregister(c)

                        for </span><span class="cov0" title="0">{
                                if _, _, err := c.ReadMessage(); err != nil </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                }))
        }
        <span class="cov0" title="0">if stockQuoteHub != nil </span><span class="cov0" title="0">{
                apiGroup.Get("/stock-quotes/ws", websocket.New(func(c *websocket.Conn) </span><span class="cov0" title="0">{
                        stockQuoteHub.Register(c)
                        defer stockQuoteHub.Unregister(c)

                        for </span><span class="cov0" title="0">{
                                if _, _, err := c.ReadMessage(); err != nil </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                }))
        }

        <span class="cov0" title="0">app.Get(contextPath+"/docs", func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                c.Set("Content-Type", "text/html; charset=utf-8")
                return c.SendString(swaggerUIHTML(contextPath))
        }</span>)
        <span class="cov0" title="0">app.Get(contextPath+"/swagger-ui.html", func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                return c.Redirect(contextPath+"/swagger-ui/index.html", fiber.StatusFound)
        }</span>)
        <span class="cov0" title="0">app.Get(contextPath+"/swagger-ui/index.html", func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                c.Set("Content-Type", "text/html; charset=utf-8")
                return c.SendString(swaggerUIHTML(contextPath))
        }</span>)

        <span class="cov0" title="0">return &amp;Server{
                cfg: cfg,
                app: app,
                log: log,
        }</span>
}

func (s *Server) Start() error <span class="cov0" title="0">{
        addr := fmt.Sprintf("%s:%d", s.cfg.Server.Host, s.cfg.Server.Port)
        return s.app.Listen(addr)
}</span>

func (s *Server) Stop() error <span class="cov0" title="0">{
        timeout := s.cfg.Server.TimeOut
        if timeout &lt;= 0 </span><span class="cov0" title="0">{
                timeout = 10 * time.Second
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()
        return s.app.ShutdownWithContext(ctx)</span>
}

func addCorrelationIDToOpenAPI(api huma.API) <span class="cov0" title="0">{
        openapi := api.OpenAPI()
        correlationParam := &amp;huma.Param{
                Name:        "X-Correlation-Id",
                In:          "header",
                Description: "Request correlation ID for tracking",
                Required:    true,
                Schema: &amp;huma.Schema{
                        Type: "string",
                },
        }
        for path := range openapi.Paths </span><span class="cov0" title="0">{
                pathItem := openapi.Paths[path]
                operations := []*huma.Operation{
                        pathItem.Get,
                        pathItem.Post,
                        pathItem.Put,
                        pathItem.Patch,
                        pathItem.Delete,
                }
                for _, op := range operations </span><span class="cov0" title="0">{
                        if op != nil </span><span class="cov0" title="0">{
                                op.Parameters = append(op.Parameters, correlationParam)
                        }</span>
                }
        }
}

func addBearerAuthToOpenAPI(api huma.API) <span class="cov0" title="0">{
        openapi := api.OpenAPI()
        security := map[string][]string{"BearerAuth": {}}
        for path := range openapi.Paths </span><span class="cov0" title="0">{
                pathItem := openapi.Paths[path]
                operations := []*huma.Operation{
                        pathItem.Get,
                        pathItem.Post,
                        pathItem.Put,
                        pathItem.Patch,
                        pathItem.Delete,
                }
                for _, op := range operations </span><span class="cov0" title="0">{
                        if op != nil </span><span class="cov0" title="0">{
                                op.Security = append(op.Security, security)
                        }</span>
                }
        }
}

func normalizeContextPath(path string) string <span class="cov0" title="0">{
        p := strings.TrimSpace(path)
        if p == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if !strings.HasPrefix(p, "/") </span><span class="cov0" title="0">{
                p = "/" + p
        }</span>
        <span class="cov0" title="0">return strings.TrimSuffix(p, "/")</span>
}

func swaggerUIHTML(contextPath string) string <span class="cov0" title="0">{
        specURL := contextPath + "/openapi.json"
        return `&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;title&gt;API Docs&lt;/title&gt;
    &lt;link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@5/swagger-ui.css" /&gt;
    &lt;style&gt;
      :root {
        --springdoc-blue: #1b78c8;
        --springdoc-blue-dark: #165f9f;
        --springdoc-bg: #f7f9fc;
        --springdoc-text: #1f2a44;
      }
      body {
        margin: 0;
        background: var(--springdoc-bg);
        color: var(--springdoc-text);
        font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
      }
      .swagger-ui .topbar {
        background-color: var(--springdoc-blue);
        border-bottom: 1px solid rgba(0,0,0,0.08);
        padding: 8px 0;
      }
      .swagger-ui .topbar .download-url-wrapper .download-url-button {
        background: var(--springdoc-blue-dark);
        border: none;
      }
      .swagger-ui .topbar .download-url-wrapper input[type="text"] {
        border: 1px solid rgba(0,0,0,0.1);
      }
      .swagger-ui .info {
        margin: 30px 0 10px;
      }
      .swagger-ui .info .title {
        color: var(--springdoc-text);
      }
      .swagger-ui .btn.authorize {
        background: var(--springdoc-blue);
        border-color: var(--springdoc-blue);
      }
      .swagger-ui .opblock.opblock-get {
        border-color: rgba(27,120,200,0.3);
        background: rgba(27,120,200,0.05);
      }
      .swagger-ui .opblock.opblock-post {
        border-color: rgba(73,204,144,0.3);
        background: rgba(73,204,144,0.05);
      }
      .swagger-ui .opblock.opblock-put {
        border-color: rgba(252,161,48,0.3);
        background: rgba(252,161,48,0.05);
      }
      .swagger-ui .opblock.opblock-delete {
        border-color: rgba(249,62,62,0.3);
        background: rgba(249,62,62,0.05);
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="swagger-ui"&gt;&lt;/div&gt;
    &lt;script src="https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      window.onload = function () {
        window.ui = SwaggerUIBundle({
          url: "` + specURL + `",
          dom_id: "#swagger-ui",
        });
      };
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
`
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package apierror

type ErrorCode string

const (
        ErrCodeNotFound       ErrorCode = "NOT_FOUND"
        ErrCodeBadRequest     ErrorCode = "BAD_REQUEST"
        ErrCodeUnauthorized   ErrorCode = "UNAUTHORIZED"
        ErrCodeForbidden      ErrorCode = "FORBIDDEN"
        ErrCodeConflict       ErrorCode = "CONFLICT"
        ErrCodeInternalError  ErrorCode = "INTERNAL_ERROR"
)

type APIError struct {
        Code    ErrorCode `json:"code"`
        Message string    `json:"message"`
        Details interface{} `json:"details,omitempty"`
        Status  int       `json:"status"`
}

func (e *APIError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

func NewNotFound(message string) *APIError <span class="cov0" title="0">{
        return &amp;APIError{
                Code:    ErrCodeNotFound,
                Message: message,
                Status:  404,
        }
}</span>

func NewBadRequest(message string) *APIError <span class="cov0" title="0">{
        return &amp;APIError{
                Code:    ErrCodeBadRequest,
                Message: message,
                Status:  400,
        }
}</span>

func NewUnauthorized(message string) *APIError <span class="cov0" title="0">{
        return &amp;APIError{
                Code:    ErrCodeUnauthorized,
                Message: message,
                Status:  401,
        }
}</span>

func NewForbidden(message string) *APIError <span class="cov0" title="0">{
        return &amp;APIError{
                Code:    ErrCodeForbidden,
                Message: message,
                Status:  403,
        }
}</span>

func NewConflict(message string) *APIError <span class="cov0" title="0">{
        return &amp;APIError{
                Code:    ErrCodeConflict,
                Message: message,
                Status:  409,
        }
}</span>

func NewInternalError(message string) *APIError <span class="cov0" title="0">{
        return &amp;APIError{
                Code:    ErrCodeInternalError,
                Message: message,
                Status:  500,
        }
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package apierror

import (
        "net/http"

        "github.com/gofiber/fiber/v2"
        status "sun-stockanalysis-api/pkg/status"
        "sun-stockanalysis-api/pkg/response"
)

// ToResponse maps application errors to a consistent HTTP status and response envelope.
func ToResponse(err error) (int, response.ApiResponse[any]) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return http.StatusOK, response.Success[any](nil)
        }</span>

        <span class="cov0" title="0">if apiErr, ok := err.(*APIError); ok </span><span class="cov0" title="0">{
                status := statusForAPIError(apiErr)
                if status.Code == "" </span><span class="cov0" title="0">{
                        status = statusForHTTP(apiErr.Status)
                }</span>
                <span class="cov0" title="0">status.Remark = err.Error()
                return apiErr.Status, response.Error(status.Code, status.Message, status.Remark)</span>
        }

        <span class="cov0" title="0">if fiberErr, ok := err.(*fiber.Error); ok </span><span class="cov0" title="0">{
                status := statusForHTTP(fiberErr.Code)
                status.Remark = err.Error()
                return fiberErr.Code, response.Error(status.Code, status.Message, status.Remark)
        }</span>

        <span class="cov0" title="0">status := statusForHTTP(http.StatusInternalServerError)
        status.Remark = err.Error()
        return http.StatusInternalServerError, response.Error(status.Code, status.Message, status.Remark)</span>
}

func statusForAPIError(apiErr *APIError) response.Status <span class="cov0" title="0">{
        switch apiErr.Code </span>{
        case ErrCodeNotFound:<span class="cov0" title="0">
                return response.Status{Code: status.CodeDataNotFound, Message: status.MsgDataNotFound}</span>
        case ErrCodeBadRequest:<span class="cov0" title="0">
                return response.Status{Code: status.CodeInvalidParam, Message: status.MsgInvalidParam}</span>
        case ErrCodeUnauthorized:<span class="cov0" title="0">
                return response.Status{Code: status.CodeUnauthorized, Message: status.MsgUnauthorized}</span>
        case ErrCodeForbidden:<span class="cov0" title="0">
                return response.Status{Code: status.CodeUnauthorized, Message: status.MsgUnauthorized}</span>
        case ErrCodeConflict:<span class="cov0" title="0">
                return response.Status{Code: status.CodeInvalidParam, Message: status.MsgInvalidParam}</span>
        case ErrCodeInternalError:<span class="cov0" title="0">
                return response.Status{Code: status.CodeSystemError, Message: status.MsgSystemError}</span>
        default:<span class="cov0" title="0">
                return response.Status{}</span>
        }
}

func statusForHTTP(httpStatus int) response.Status <span class="cov0" title="0">{
        switch httpStatus </span>{
        case http.StatusBadRequest:<span class="cov0" title="0">
                return response.Status{Code: status.CodeInvalidParam, Message: status.MsgInvalidParam}</span>
        case http.StatusUnauthorized:<span class="cov0" title="0">
                return response.Status{Code: status.CodeUnauthorized, Message: status.MsgUnauthorized}</span>
        case http.StatusForbidden:<span class="cov0" title="0">
                return response.Status{Code: status.CodeUnauthorized, Message: status.MsgUnauthorized}</span>
        case http.StatusNotFound:<span class="cov0" title="0">
                return response.Status{Code: status.CodeDataNotFound, Message: status.MsgDataNotFound}</span>
        case http.StatusConflict:<span class="cov0" title="0">
                return response.Status{Code: status.CodeInvalidParam, Message: status.MsgInvalidParam}</span>
        case http.StatusRequestTimeout:<span class="cov0" title="0">
                return response.Status{Code: status.CodeRequestTimeout, Message: status.MsgRequestTimeout}</span>
        case http.StatusInternalServerError:<span class="cov0" title="0">
                return response.Status{Code: status.CodeSystemError, Message: status.MsgSystemError}</span>
        default:<span class="cov0" title="0">
                return response.Status{Code: status.CodeGeneralError, Message: status.MsgGeneralError}</span>
        }
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package apierror

import (
        "net/http"

        "github.com/danielgtaylor/huma/v2"
        "github.com/gofiber/fiber/v2"
        "sun-stockanalysis-api/pkg/response"
)

// HumaError is the shared error envelope for Huma responses.
type HumaError struct {
        Status response.Status `json:"status"`
        Data   any             `json:"data"`
        status int
}

func (e *HumaError) Error() string <span class="cov0" title="0">{
        return e.Status.Message
}</span>

func (e *HumaError) GetStatus() int <span class="cov0" title="0">{
        return e.status
}</span>

// NewHumaError creates a Huma StatusError using the business error envelope.
func NewHumaError(status int, msg string, errs ...error) huma.StatusError <span class="cov0" title="0">{
        businessStatus := statusForHTTP(status)
        remark := msg
        if len(errs) &gt; 0 &amp;&amp; errs[0] != nil </span><span class="cov0" title="0">{
                remark = errs[0].Error()
        }</span>

        <span class="cov0" title="0">return &amp;HumaError{
                Status: response.Status{
                        Code:    businessStatus.Code,
                        Message: businessStatus.Message,
                        Remark:  remark,
                },
                Data:   nil,
                status: status,
        }</span>
}

// ToHumaError maps application errors to the shared Huma error envelope.
func ToHumaError(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if statusErr, ok := err.(huma.StatusError); ok </span><span class="cov0" title="0">{
                return statusErr
        }</span>

        <span class="cov0" title="0">if apiErr, ok := err.(*APIError); ok </span><span class="cov0" title="0">{
                status := statusForAPIError(apiErr)
                if status.Code == "" </span><span class="cov0" title="0">{
                        status = statusForHTTP(apiErr.Status)
                }</span>
                <span class="cov0" title="0">return &amp;HumaError{
                        Status: response.Status{
                                Code:    status.Code,
                                Message: status.Message,
                                Remark:  err.Error(),
                        },
                        Data:   nil,
                        status: apiErr.Status,
                }</span>
        }

        <span class="cov0" title="0">if fiberErr, ok := err.(*fiber.Error); ok </span><span class="cov0" title="0">{
                status := statusForHTTP(fiberErr.Code)
                return &amp;HumaError{
                        Status: response.Status{
                                Code:    status.Code,
                                Message: status.Message,
                                Remark:  err.Error(),
                        },
                        Data:   nil,
                        status: fiberErr.Code,
                }
        }</span>

        <span class="cov0" title="0">return NewHumaError(http.StatusInternalServerError, "Internal server error", err)</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package logger

import (
        "context"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

type Logger struct {
        *zap.SugaredLogger
}

type contextKey string

const correlationIDKey contextKey = "correlation_id"

var CorrelationIDKey = correlationIDKey

func NewLogger(level string) *Logger <span class="cov0" title="0">{
        config := zap.NewDevelopmentConfig()
        config.EncoderConfig.TimeKey = "time"
        config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder

        switch level </span>{
        case "debug":<span class="cov0" title="0">
                config.Level = zap.NewAtomicLevelAt(zapcore.DebugLevel)</span>
        case "info":<span class="cov0" title="0">
                config.Level = zap.NewAtomicLevelAt(zapcore.InfoLevel)</span>
        case "warn":<span class="cov0" title="0">
                config.Level = zap.NewAtomicLevelAt(zapcore.WarnLevel)</span>
        case "error":<span class="cov0" title="0">
                config.Level = zap.NewAtomicLevelAt(zapcore.ErrorLevel)</span>
        default:<span class="cov0" title="0">
                config.Level = zap.NewAtomicLevelAt(zapcore.InfoLevel)</span>
        }

        <span class="cov0" title="0">zapLogger, _ := config.Build()
        return &amp;Logger{zapLogger.Sugar()}</span>
}

func (l *Logger) WithCorrelationID(ctx context.Context) *zap.SugaredLogger <span class="cov0" title="0">{
        if l == nil || l.SugaredLogger == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if ctx == nil </span><span class="cov0" title="0">{
                return l.SugaredLogger
        }</span>
        <span class="cov0" title="0">if val := ctx.Value(correlationIDKey); val != nil </span><span class="cov0" title="0">{
                if id, ok := val.(string); ok &amp;&amp; id != "" </span><span class="cov0" title="0">{
                        return l.SugaredLogger.With("correlation_id", id)
                }</span>
        }
        <span class="cov0" title="0">return l.SugaredLogger</span>
}

func (l *Logger) Infof(format string, args ...interface{}) <span class="cov0" title="0">{
        l.SugaredLogger.Infof(format, args...)
}</span>

func (l *Logger) Warnf(format string, args ...interface{}) <span class="cov0" title="0">{
        l.SugaredLogger.Warnf(format, args...)
}</span>

func (l *Logger) Errorf(format string, args ...interface{}) <span class="cov0" title="0">{
        l.SugaredLogger.Errorf(format, args...)
}</span>

func (l *Logger) Debugf(format string, args ...interface{}) <span class="cov0" title="0">{
        l.SugaredLogger.Debugf(format, args...)
}</span>

func (l *Logger) Fatalf(format string, args ...interface{}) <span class="cov0" title="0">{
        l.SugaredLogger.Fatalf(format, args...)
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package response

import status "sun-stockanalysis-api/pkg/status"

type Status struct {
        Code    string `json:"code"`
        Message string `json:"message"`
        Remark  string `json:"remark"`
}

type ApiResponse[T any] struct {
        Status Status `json:"status"`
        Data   T      `json:"data"`
}

func Success[T any](data T) ApiResponse[T] <span class="cov0" title="0">{
        return ApiResponse[T]{
                Status: Status{
                        Code:    status.CodeSuccess,
                        Message: status.MsgSuccess,
                        Remark:  "",
                },
                Data: data,
        }
}</span>

func Error(code, message, remark string) ApiResponse[any] <span class="cov0" title="0">{
        return ApiResponse[any]{
                Status: Status{
                        Code:    code,
                        Message: message,
                        Remark:  remark,
                },
                Data: nil,
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
